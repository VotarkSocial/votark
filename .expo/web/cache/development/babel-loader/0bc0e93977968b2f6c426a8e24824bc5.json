{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport DeviceEventEmitter from \"react-native-web/dist/exports/DeviceEventEmitter\";\nimport { NativeAppEventEmitter } from \"react-native-web/dist/index\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport AsyncStorage from \"react-native-web/dist/exports/AsyncStorage\";\nimport AppState from \"react-native-web/dist/exports/AppState\";\nimport URIUtil from \"./utils/uri\";\nimport StatefulPromise from \"./class/StatefulPromise.js\";\nimport fs from \"./fs\";\nimport getUUID from \"./utils/uuid\";\nimport base64 from 'base-64';\nimport polyfill from \"./polyfill\";\nimport _ from 'lodash';\nimport android from \"./android\";\nimport ios from \"./ios\";\nimport JSONStream from \"./json-stream\";\nvar RNFetchBlobSession = fs.RNFetchBlobSession,\n    readStream = fs.readStream,\n    createFile = fs.createFile,\n    unlink = fs.unlink,\n    exists = fs.exists,\n    mkdir = fs.mkdir,\n    session = fs.session,\n    writeStream = fs.writeStream,\n    readFile = fs.readFile,\n    ls = fs.ls,\n    isDir = fs.isDir,\n    mv = fs.mv,\n    cp = fs.cp;\nvar Blob = polyfill.Blob;\nvar emitter = DeviceEventEmitter;\nvar RNFetchBlob = NativeModules.RNFetchBlob;\n\nif (Platform.OS === 'ios') {\n  AppState.addEventListener('change', function (e) {\n    if (e === 'active') RNFetchBlob.emitExpiredEvent(function () {});\n  });\n}\n\nemitter.addListener(\"RNFetchBlobMessage\", function (e) {\n  if (e.event === 'warn') {\n    console.warn(e.detail);\n  } else if (e.event === 'error') {\n    throw e.detail;\n  } else {\n    console.log(\"RNFetchBlob native message\", e.detail);\n  }\n});\n\nif (!RNFetchBlob || !RNFetchBlob.fetchBlobForm || !RNFetchBlob.fetchBlob) {\n  console.warn('react-native-fetch-blob could not find valid native module.', 'please make sure you have linked native modules using `rnpm link`,', 'and restart RN packager or manually compile IOS/Android project.');\n}\n\nfunction wrap(path) {\n  return 'RNFetchBlob-file://' + path;\n}\n\nfunction config(options) {\n  return {\n    fetch: fetch.bind(options)\n  };\n}\n\nfunction fetchFile() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var method = arguments.length > 1 ? arguments[1] : undefined;\n  var url = arguments.length > 2 ? arguments[2] : undefined;\n  var headers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var body = arguments.length > 4 ? arguments[4] : undefined;\n\n  if (!URIUtil.isFileURI(url)) {\n    throw \"could not fetch file from an invalid URI : \" + url;\n  }\n\n  url = URIUtil.unwrapFileURI(url);\n  var promise = null;\n  var cursor = 0;\n  var total = -1;\n  var cacheData = '';\n  var info = null;\n\n  var _progress, _uploadProgress, _stateChange;\n\n  switch (method.toLowerCase()) {\n    case 'post':\n      break;\n\n    case 'put':\n      break;\n\n    default:\n      promise = fs.stat(url).then(function (stat) {\n        total = stat.size;\n        return fs.readStream(url, headers.encoding || 'utf8', Math.floor(headers.bufferSize) || 409600, Math.floor(headers.interval) || 100);\n      }).then(function (stream) {\n        return new Promise(function (resolve, reject) {\n          stream.open();\n          info = {\n            state: \"2\",\n            headers: {\n              'source': 'system-fs'\n            },\n            status: 200,\n            respType: 'text',\n            rnfbEncode: headers.encoding || 'utf8'\n          };\n\n          _stateChange(info);\n\n          stream.onData(function (chunk) {\n            _progress && _progress(cursor, total, chunk);\n            if (headers.noCache) return;\n            cacheData += chunk;\n          });\n          stream.onError(function (err) {\n            reject(err);\n          });\n          stream.onEnd(function () {\n            resolve(new FetchBlobResponse(null, info, cacheData));\n          });\n        });\n      });\n      break;\n  }\n\n  promise.progress = function (fn) {\n    _progress = fn;\n    return promise;\n  };\n\n  promise.stateChange = function (fn) {\n    _stateChange = fn;\n    return promise;\n  };\n\n  promise.uploadProgress = function (fn) {\n    _uploadProgress = fn;\n    return promise;\n  };\n\n  return promise;\n}\n\nfunction fetch() {\n  var taskId = getUUID();\n  var options = this || {};\n  var subscription, subscriptionUpload, stateEvent, partEvent;\n  var respInfo = {};\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var _ref = [].concat(args),\n      method = _ref[0],\n      url = _ref[1],\n      headers = _ref[2],\n      body = _ref[3];\n\n  headers = _.reduce(headers, function (result, value, key) {\n    result[key] = value || '';\n    return result;\n  }, {});\n\n  if (URIUtil.isFileURI(url)) {\n    return fetchFile(options, method, url, headers, body);\n  }\n\n  var promise = new Promise(function (resolve, reject) {\n    var nativeMethodName = Array.isArray(body) ? 'fetchBlobForm' : 'fetchBlob';\n    subscription = emitter.addListener('RNFetchBlobProgress', function (e) {\n      if (e.taskId === taskId && promise.onProgress) {\n        promise.onProgress(e.written, e.total, e.chunk);\n      }\n    });\n    subscriptionUpload = emitter.addListener('RNFetchBlobProgress-upload', function (e) {\n      if (e.taskId === taskId && promise.onUploadProgress) {\n        promise.onUploadProgress(e.written, e.total);\n      }\n    });\n    stateEvent = emitter.addListener('RNFetchBlobState', function (e) {\n      if (e.taskId === taskId) respInfo = e;\n      promise.onStateChange && promise.onStateChange(e);\n    });\n    subscription = emitter.addListener('RNFetchBlobExpire', function (e) {\n      if (e.taskId === taskId && promise.onExpire) {\n        promise.onExpire(e);\n      }\n    });\n    partEvent = emitter.addListener('RNFetchBlobServerPush', function (e) {\n      if (e.taskId === taskId && promise.onPartData) {\n        promise.onPartData(e.chunk);\n      }\n    });\n\n    if (body instanceof Blob && body.isRNFetchBlobPolyfill) {\n      body = body.getRNFetchBlobRef();\n    }\n\n    var req = RNFetchBlob[nativeMethodName];\n    req(options, taskId, method, url, headers || {}, body, function (err, rawType, data) {\n      subscription.remove();\n      subscriptionUpload.remove();\n      stateEvent.remove();\n      partEvent.remove();\n      delete promise['progress'];\n      delete promise['uploadProgress'];\n      delete promise['stateChange'];\n      delete promise['part'];\n      delete promise['cancel'];\n\n      promise.cancel = function () {};\n\n      if (err) reject(new Error(err, respInfo));else {\n        if (options.path || options.fileCache || options.addAndroidDownloads || options.key || options.auto && respInfo.respType === 'blob') {\n          if (options.session) session(options.session).add(data);\n        }\n\n        respInfo.rnfbEncode = rawType;\n        resolve(new FetchBlobResponse(taskId, respInfo, data));\n      }\n    });\n  });\n\n  promise.progress = function () {\n    var interval = 250;\n    var count = -1;\n\n    var fn = function fn() {};\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    if (args.length === 2) {\n      interval = args[0].interval || interval;\n      count = args[0].count || count;\n      fn = args[1];\n    } else {\n      fn = args[0];\n    }\n\n    promise.onProgress = fn;\n    RNFetchBlob.enableProgressReport(taskId, interval, count);\n    return promise;\n  };\n\n  promise.uploadProgress = function () {\n    var interval = 250;\n    var count = -1;\n\n    var fn = function fn() {};\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    if (args.length === 2) {\n      interval = args[0].interval || interval;\n      count = args[0].count || count;\n      fn = args[1];\n    } else {\n      fn = args[0];\n    }\n\n    promise.onUploadProgress = fn;\n    RNFetchBlob.enableUploadProgressReport(taskId, interval, count);\n    return promise;\n  };\n\n  promise.part = function (fn) {\n    promise.onPartData = fn;\n    return promise;\n  };\n\n  promise.stateChange = function (fn) {\n    promise.onStateChange = fn;\n    return promise;\n  };\n\n  promise.expire = function (fn) {\n    promise.onExpire = fn;\n    return promise;\n  };\n\n  promise.cancel = function (fn) {\n    fn = fn || function () {};\n\n    subscription.remove();\n    subscriptionUpload.remove();\n    stateEvent.remove();\n    RNFetchBlob.cancelRequest(taskId, fn);\n  };\n\n  promise.taskId = taskId;\n  return promise;\n}\n\nvar FetchBlobResponse = function FetchBlobResponse(taskId, info, data) {\n  var _this = this;\n\n  _classCallCheck(this, FetchBlobResponse);\n\n  this.data = data;\n  this.taskId = taskId;\n  this.type = info.rnfbEncode;\n  this.respInfo = info;\n\n  this.info = function () {\n    return _this.respInfo;\n  };\n\n  this.array = function () {\n    var cType = info.headers['Content-Type'] || info.headers['content-type'];\n    return new Promise(function (resolve, reject) {\n      switch (_this.type) {\n        case 'base64':\n          break;\n\n        case 'path':\n          fs.readFile(_this.data, 'ascii').then(resolve);\n          break;\n\n        default:\n          break;\n      }\n    });\n  };\n\n  this.blob = function () {\n    var Blob = polyfill.Blob;\n    var cType = info.headers['Content-Type'] || info.headers['content-type'];\n    return new Promise(function (resolve, reject) {\n      switch (_this.type) {\n        case 'base64':\n          Blob.build(_this.data, {\n            type: cType + ';BASE64'\n          }).then(resolve);\n          break;\n\n        case 'path':\n          polyfill.Blob.build(wrap(_this.data), {\n            type: cType\n          }).then(resolve);\n          break;\n\n        default:\n          polyfill.Blob.build(_this.data, {\n            type: 'text/plain'\n          }).then(resolve);\n          break;\n      }\n    });\n  };\n\n  this.text = function () {\n    var res = _this.data;\n\n    switch (_this.type) {\n      case 'base64':\n        return base64.decode(_this.data);\n\n      case 'path':\n        return fs.readFile(_this.data, 'base64').then(function (b64) {\n          return Promise.resolve(base64.decode(b64));\n        });\n\n      default:\n        return _this.data;\n    }\n  };\n\n  this.json = function () {\n    switch (_this.type) {\n      case 'base64':\n        return JSON.parse(base64.decode(_this.data));\n\n      case 'path':\n        return fs.readFile(_this.data, 'utf8').then(function (text) {\n          return Promise.resolve(JSON.parse(text));\n        });\n\n      default:\n        return JSON.parse(_this.data);\n    }\n  };\n\n  this.base64 = function () {\n    switch (_this.type) {\n      case 'base64':\n        return _this.data;\n\n      case 'path':\n        return fs.readFile(_this.data, 'base64');\n\n      default:\n        return base64.encode(_this.data);\n    }\n  };\n\n  this.flush = function () {\n    var path = _this.path();\n\n    if (!path || _this.type !== 'path') return;\n    return unlink(path);\n  };\n\n  this.path = function () {\n    if (_this.type === 'path') return _this.data;\n    return null;\n  };\n\n  this.session = function (name) {\n    if (_this.type === 'path') return session(name).add(_this.data);else {\n      console.warn('only file paths can be add into session.');\n      return null;\n    }\n  };\n\n  this.readStream = function (encode) {\n    if (_this.type === 'path') {\n      return readStream(_this.data, encode);\n    } else {\n      console.warn('RNFetchblob', 'this response data does not contains any available stream');\n      return null;\n    }\n  };\n\n  this.readFile = function (encode) {\n    if (_this.type === 'path') {\n      encode = encode || 'utf8';\n      return readFile(_this.data, encode);\n    } else {\n      console.warn('RNFetchblob', 'this response does not contains a readable file');\n      return null;\n    }\n  };\n};\n\nexport default {\n  fetch: fetch,\n  base64: base64,\n  android: android,\n  ios: ios,\n  config: config,\n  session: session,\n  fs: fs,\n  wrap: wrap,\n  polyfill: polyfill,\n  JSONStream: JSONStream\n};","map":{"version":3,"sources":["/home/thecoder/Documentos/votark/votark/node_modules/react-native-fetch-blob/index.js"],"names":["NativeAppEventEmitter","URIUtil","StatefulPromise","fs","getUUID","base64","polyfill","_","android","ios","JSONStream","RNFetchBlobSession","readStream","createFile","unlink","exists","mkdir","session","writeStream","readFile","ls","isDir","mv","cp","Blob","emitter","DeviceEventEmitter","RNFetchBlob","NativeModules","Platform","OS","AppState","addEventListener","e","emitExpiredEvent","addListener","event","console","warn","detail","log","fetchBlobForm","fetchBlob","wrap","path","config","options","fetch","bind","fetchFile","method","url","headers","body","isFileURI","unwrapFileURI","promise","cursor","total","cacheData","info","_progress","_uploadProgress","_stateChange","toLowerCase","stat","then","size","encoding","Math","floor","bufferSize","interval","stream","Promise","resolve","reject","open","state","status","respType","rnfbEncode","onData","chunk","noCache","onError","err","onEnd","FetchBlobResponse","progress","fn","stateChange","uploadProgress","taskId","subscription","subscriptionUpload","stateEvent","partEvent","respInfo","args","reduce","result","value","key","nativeMethodName","Array","isArray","onProgress","written","onUploadProgress","onStateChange","onExpire","onPartData","isRNFetchBlobPolyfill","getRNFetchBlobRef","req","rawType","data","remove","cancel","Error","fileCache","addAndroidDownloads","auto","add","count","length","enableProgressReport","enableUploadProgressReport","part","expire","cancelRequest","type","array","cType","blob","build","text","res","decode","b64","json","JSON","parse","encode","flush","name"],"mappings":"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","sourcesContent":["// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport {\n  NativeModules,\n  DeviceEventEmitter,\n  NativeAppEventEmitter,\n  Platform,\n  AsyncStorage,\n  AppState,\n} from 'react-native'\nimport type {\n  RNFetchBlobNative,\n  RNFetchBlobConfig,\n  RNFetchBlobStream,\n  RNFetchBlobResponseInfo\n} from './types'\nimport URIUtil from './utils/uri'\nimport StatefulPromise from './class/StatefulPromise.js'\nimport fs from './fs'\nimport getUUID from './utils/uuid'\nimport base64 from 'base-64'\nimport polyfill from './polyfill'\nimport _ from 'lodash'\nimport android from './android'\nimport ios from './ios'\nimport JSONStream from './json-stream'\nconst {\n  RNFetchBlobSession,\n  readStream,\n  createFile,\n  unlink,\n  exists,\n  mkdir,\n  session,\n  writeStream,\n  readFile,\n  ls,\n  isDir,\n  mv,\n  cp\n} = fs\n\nconst Blob = polyfill.Blob\nconst emitter = DeviceEventEmitter\nconst RNFetchBlob = NativeModules.RNFetchBlob\n\n// when app resumes, check if there's any expired network task and trigger\n// their .expire event\nif(Platform.OS === 'ios') {\n  AppState.addEventListener('change', (e) => {\n    if(e === 'active')\n      RNFetchBlob.emitExpiredEvent(()=>{})\n  })\n}\n\n// register message channel event handler.\nemitter.addListener(\"RNFetchBlobMessage\", (e) => {\n\n  if(e.event === 'warn') {\n    console.warn(e.detail)\n  }\n  else if (e.event === 'error') {\n    throw e.detail\n  }\n  else {\n    console.log(\"RNFetchBlob native message\", e.detail)\n  }\n})\n\n// Show warning if native module not detected\nif(!RNFetchBlob || !RNFetchBlob.fetchBlobForm || !RNFetchBlob.fetchBlob) {\n  console.warn(\n    'react-native-fetch-blob could not find valid native module.',\n    'please make sure you have linked native modules using `rnpm link`,',\n    'and restart RN packager or manually compile IOS/Android project.'\n  )\n}\n\nfunction wrap(path:string):string {\n  return 'RNFetchBlob-file://' + path\n}\n\n/**\n * Calling this method will inject configurations into followed `fetch` method.\n * @param  {RNFetchBlobConfig} options\n *         Fetch API configurations, contains the following options :\n *         @property {boolean} fileCache\n *                   When fileCache is `true`, response data will be saved in\n *                   storage with a random generated file name, rather than\n *                   a BASE64 encoded string.\n *         @property {string} appendExt\n *                   Set this property to change file extension of random-\n *                   generated file name.\n *         @property {string} path\n *                   If this property has a valid string format, resonse data\n *                   will be saved to specific file path. Default string format\n *                   is : `RNFetchBlob-file://path-to-file`\n *         @property {string} key\n *                   If this property is set, it will be converted to md5, to\n *                   check if a file with this name exists.\n *                   If it exists, the absolute path is returned (no network\n *                   activity takes place )\n *                   If it doesn't exist, the file is downloaded as usual\n *         @property {number} timeout\n *                   Request timeout in millionseconds, by default it's 30000ms.\n *\n * @return {function} This method returns a `fetch` method instance.\n */\nfunction config (options:RNFetchBlobConfig) {\n  return { fetch : fetch.bind(options) }\n}\n\n/**\n * Fetch from file system, use the same interface as RNFB.fetch\n * @param  {RNFetchBlobConfig} [options={}] Fetch configurations\n * @param  {string} method     Should be one of `get`, `post`, `put`\n * @param  {string} url        A file URI string\n * @param  {string} headers    Arguments of file system API\n * @param  {any} body       Data to put or post to file systen.\n * @return {Promise}\n */\nfunction fetchFile(options = {}, method, url, headers = {}, body):Promise {\n\n  if(!URIUtil.isFileURI(url)) {\n    throw `could not fetch file from an invalid URI : ${url}`\n  }\n\n  url = URIUtil.unwrapFileURI(url)\n\n  let promise = null\n  let cursor = 0\n  let total = -1\n  let cacheData = ''\n  let info = null\n  let _progress, _uploadProgress, _stateChange\n\n  switch(method.toLowerCase()) {\n\n    case 'post':\n    break\n\n    case 'put':\n    break\n\n    // read data from file system\n    default:\n      promise = fs.stat(url)\n      .then((stat) => {\n        total = stat.size\n        return fs.readStream(url,\n          headers.encoding || 'utf8',\n          Math.floor(headers.bufferSize) || 409600,\n          Math.floor(headers.interval) || 100\n        )\n      })\n      .then((stream) => new Promise((resolve, reject) => {\n        stream.open()\n        info = {\n          state : \"2\",\n          headers : { 'source' : 'system-fs' },\n          status : 200,\n          respType : 'text',\n          rnfbEncode : headers.encoding || 'utf8'\n        }\n        _stateChange(info)\n        stream.onData((chunk) => {\n          _progress && _progress(cursor, total, chunk)\n          if(headers.noCache)\n            return\n          cacheData += chunk\n        })\n        stream.onError((err) => { reject(err) })\n        stream.onEnd(() => {\n          resolve(new FetchBlobResponse(null, info, cacheData))\n        })\n      }))\n    break\n  }\n\n  promise.progress = (fn) => {\n    _progress = fn\n    return promise\n  }\n  promise.stateChange = (fn) => {\n    _stateChange = fn\n    return promise\n  }\n  promise.uploadProgress = (fn) => {\n    _uploadProgress = fn\n    return promise\n  }\n\n  return promise\n}\n\n/**\n * Create a HTTP request by settings, the `this` context is a `RNFetchBlobConfig` object.\n * @param  {string} method HTTP method, should be `GET`, `POST`, `PUT`, `DELETE`\n * @param  {string} url Request target url string.\n * @param  {object} headers HTTP request headers.\n * @param  {string} body\n *         Request body, can be either a BASE64 encoded data string,\n *         or a file path with prefix `RNFetchBlob-file://` (can be changed)\n * @return {Promise}\n *         This promise instance also contains a Customized method `progress`for\n *         register progress event handler.\n */\nfunction fetch(...args:any):Promise {\n\n  // create task ID for receiving progress event\n  let taskId = getUUID()\n  let options = this || {}\n  let subscription, subscriptionUpload, stateEvent, partEvent\n  let respInfo = {}\n  let [method, url, headers, body] = [...args]\n\n  // # 241 normalize null or undefined headers, in case nil or null string\n  // pass to native context\n  headers = _.reduce(headers, (result, value, key) => {\n    result[key] = value || ''\n    return result\n  }, {});\n\n  // fetch from file system\n  if(URIUtil.isFileURI(url)) {\n    return fetchFile(options, method, url, headers, body)\n  }\n\n  // from remote HTTP(S)\n  let promise = new Promise((resolve, reject) => {\n    let nativeMethodName = Array.isArray(body) ? 'fetchBlobForm' : 'fetchBlob'\n\n    // on progress event listener\n    subscription = emitter.addListener('RNFetchBlobProgress', (e) => {\n      if(e.taskId === taskId && promise.onProgress) {\n        promise.onProgress(e.written, e.total, e.chunk)\n      }\n    })\n\n    subscriptionUpload = emitter.addListener('RNFetchBlobProgress-upload', (e) => {\n      if(e.taskId === taskId && promise.onUploadProgress) {\n        promise.onUploadProgress(e.written, e.total)\n      }\n    })\n\n    stateEvent = emitter.addListener('RNFetchBlobState', (e) => {\n      if(e.taskId === taskId)\n        respInfo = e\n      promise.onStateChange && promise.onStateChange(e)\n    })\n\n    subscription = emitter.addListener('RNFetchBlobExpire', (e) => {\n      if(e.taskId === taskId && promise.onExpire) {\n        promise.onExpire(e)\n      }\n    })\n\n    partEvent = emitter.addListener('RNFetchBlobServerPush', (e) => {\n      if(e.taskId === taskId && promise.onPartData) {\n        promise.onPartData(e.chunk)\n      }\n    })\n\n    // When the request body comes from Blob polyfill, we should use special its ref\n    // as the request body\n    if( body instanceof Blob && body.isRNFetchBlobPolyfill) {\n      body = body.getRNFetchBlobRef()\n    }\n\n    let req = RNFetchBlob[nativeMethodName]\n\n    /**\n     * Send request via native module, the response callback accepts three arguments\n     * @callback\n     * @param err {any} Error message or object, when the request success, this\n     *                  parameter should be `null`.\n     * @param rawType { 'utf8' | 'base64' | 'path'} RNFB request will be stored\n     *                  as UTF8 string, BASE64 string, or a file path reference\n     *                  in JS context, and this parameter indicates which one\n     *                  dose the response data presents.\n     * @param data {string} Response data or its reference.\n     */\n    req(options, taskId, method, url, headers || {}, body, (err, rawType, data) => {\n\n      // task done, remove event listeners\n      subscription.remove()\n      subscriptionUpload.remove()\n      stateEvent.remove()\n      partEvent.remove()\n      delete promise['progress']\n      delete promise['uploadProgress']\n      delete promise['stateChange']\n      delete promise['part']\n      delete promise['cancel']\n      // delete promise['expire']\n      promise.cancel = () => {}\n\n      if(err)\n        reject(new Error(err, respInfo))\n      else {\n        // response data is saved to storage, create a session for it\n        if(options.path || options.fileCache || options.addAndroidDownloads\n          || options.key || options.auto && respInfo.respType === 'blob') {\n          if(options.session)\n            session(options.session).add(data)\n        }\n        respInfo.rnfbEncode = rawType\n        resolve(new FetchBlobResponse(taskId, respInfo, data))\n      }\n\n    })\n\n  })\n\n  // extend Promise object, add `progress`, `uploadProgress`, and `cancel`\n  // method for register progress event handler and cancel request.\n  // Add second parameter for performance purpose #140\n  // When there's only one argument pass to this method, use default `interval`\n  // and `count`, otherwise use the given on.\n  // TODO : code refactor, move `uploadProgress` and `progress` to StatefulPromise\n  promise.progress = (...args) => {\n    let interval = 250\n    let count = -1\n    let fn = () => {}\n    if(args.length === 2) {\n      interval = args[0].interval || interval\n      count = args[0].count || count\n      fn = args[1]\n    }\n    else {\n      fn = args[0]\n    }\n    promise.onProgress = fn\n    RNFetchBlob.enableProgressReport(taskId, interval, count)\n    return promise\n  }\n  promise.uploadProgress = (...args) => {\n    let interval = 250\n    let count = -1\n    let fn = () => {}\n    if(args.length === 2) {\n      interval = args[0].interval || interval\n      count = args[0].count || count\n      fn = args[1]\n    }\n    else {\n      fn = args[0]\n    }\n    promise.onUploadProgress = fn\n    RNFetchBlob.enableUploadProgressReport(taskId, interval, count)\n    return promise\n  }\n  promise.part = (fn) => {\n    promise.onPartData = fn\n    return promise\n  }\n  promise.stateChange = (fn) => {\n    promise.onStateChange = fn\n    return promise\n  }\n  promise.expire = (fn) => {\n    promise.onExpire = fn\n    return promise\n  }\n  promise.cancel = (fn) => {\n    fn = fn || function(){}\n    subscription.remove()\n    subscriptionUpload.remove()\n    stateEvent.remove()\n    RNFetchBlob.cancelRequest(taskId, fn)\n  }\n  promise.taskId = taskId\n\n  return promise\n\n}\n\n/**\n * RNFetchBlob response object class.\n */\nclass FetchBlobResponse {\n\n  taskId : string;\n  path : () => string | null;\n  type : 'base64' | 'path' | 'utf8';\n  data : any;\n  blob : (contentType:string, sliceSize:number) => Promise<Blob>;\n  text : () => string | Promise<any>;\n  json : () => any;\n  base64 : () => any;\n  flush : () => void;\n  respInfo : RNFetchBlobResponseInfo;\n  session : (name:string) => RNFetchBlobSession | null;\n  readFile : (encode: 'base64' | 'utf8' | 'ascii') => ?Promise<any>;\n  readStream : (\n    encode: 'utf8' | 'ascii' | 'base64',\n  ) => RNFetchBlobStream | null;\n\n  constructor(taskId:string, info:RNFetchBlobResponseInfo, data:any) {\n    this.data = data\n    this.taskId = taskId\n    this.type = info.rnfbEncode\n    this.respInfo = info\n\n    this.info = ():RNFetchBlobResponseInfo => {\n      return this.respInfo\n    }\n\n    this.array = ():Promise<Array> => {\n      let cType = info.headers['Content-Type'] || info.headers['content-type']\n      return new Promise((resolve, reject) => {\n        switch(this.type) {\n          case 'base64':\n            // TODO : base64 to array buffer\n          break\n          case 'path':\n            fs.readFile(this.data, 'ascii').then(resolve)\n          break\n          default:\n            // TODO : text to array buffer\n          break\n        }\n      })\n    }\n\n    /**\n     * Convert result to javascript RNFetchBlob object.\n     * @return {Promise<Blob>} Return a promise resolves Blob object.\n     */\n    this.blob = ():Promise<Blob> => {\n      let Blob = polyfill.Blob\n      let cType = info.headers['Content-Type'] || info.headers['content-type']\n      return new Promise((resolve, reject) => {\n        switch(this.type) {\n          case 'base64':\n            Blob.build(this.data, { type : cType + ';BASE64' }).then(resolve)\n          break\n          case 'path':\n            polyfill.Blob.build(wrap(this.data), { type : cType }).then(resolve)\n          break\n          default:\n            polyfill.Blob.build(this.data, { type : 'text/plain' }).then(resolve)\n          break\n        }\n      })\n    }\n    /**\n     * Convert result to text.\n     * @return {string} Decoded base64 string.\n     */\n    this.text = ():string | Promise<any> => {\n      let res = this.data\n      switch(this.type) {\n        case 'base64':\n          return base64.decode(this.data)\n        case 'path':\n          return fs.readFile(this.data, 'base64').then((b64) => Promise.resolve(base64.decode(b64)))\n        default:\n          return this.data\n      }\n    }\n    /**\n     * Convert result to JSON object.\n     * @return {object} Parsed javascript object.\n     */\n    this.json = ():any => {\n      switch(this.type) {\n        case 'base64':\n          return JSON.parse(base64.decode(this.data))\n        case 'path':\n          return fs.readFile(this.data, 'utf8')\n                   .then((text) => Promise.resolve(JSON.parse(text)))\n        default:\n          return JSON.parse(this.data)\n      }\n    }\n    /**\n     * Return BASE64 string directly.\n     * @return {string} BASE64 string of response body.\n     */\n    this.base64 = ():string | Promise<any> => {\n      switch(this.type) {\n        case 'base64':\n          return this.data\n        case 'path':\n          return fs.readFile(this.data, 'base64')\n        default:\n          return base64.encode(this.data)\n      }\n    }\n    /**\n     * Remove cahced file\n     * @return {Promise}\n     */\n    this.flush = () => {\n      let path = this.path()\n      if(!path || this.type !== 'path')\n        return\n      return unlink(path)\n    }\n    /**\n     * get path of response temp file\n     * @return {string} File path of temp file.\n     */\n    this.path = () => {\n      if(this.type === 'path')\n        return this.data\n      return null\n    }\n\n    this.session = (name:string):RNFetchBlobSession | null => {\n      if(this.type === 'path')\n        return session(name).add(this.data)\n      else {\n        console.warn('only file paths can be add into session.')\n        return null\n      }\n    }\n    /**\n     * Start read stream from cached file\n     * @param  {String} encoding Encode type, should be one of `base64`, `ascrii`, `utf8`.\n     * @param  {Function} fn On data event handler\n     * @return {void}\n     */\n    this.readStream = (encode: 'base64' | 'utf8' | 'ascii'):RNFetchBlobStream | null => {\n      if(this.type === 'path') {\n        return readStream(this.data, encode)\n      }\n      else {\n        console.warn('RNFetchblob', 'this response data does not contains any available stream')\n        return null\n      }\n    }\n    /**\n     * Read file content with given encoding, if the response does not contains\n     * a file path, show warning message\n     * @param  {String} encoding Encode type, should be one of `base64`, `ascrii`, `utf8`.\n     * @return {String}\n     */\n    this.readFile = (encode: 'base64' | 'utf8' | 'ascii') => {\n      if(this.type === 'path') {\n        encode = encode || 'utf8'\n        return readFile(this.data, encode)\n      }\n      else {\n        console.warn('RNFetchblob', 'this response does not contains a readable file')\n        return null\n      }\n    }\n  }\n\n}\n\nexport default {\n  fetch,\n  base64,\n  android,\n  ios,\n  config,\n  session,\n  fs,\n  wrap,\n  polyfill,\n  JSONStream\n}\n"]},"metadata":{},"sourceType":"module"}