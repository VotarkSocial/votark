{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport queryString from 'query-string';\nexport default function getPathFromState(state) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (state === undefined) {\n    throw Error('NavigationState not passed');\n  }\n\n  var configs = createNormalizedConfigs(options);\n  var path = '/';\n  var current = state;\n  var allParams = {};\n\n  var _loop = function _loop() {\n    var index = typeof current.index === 'number' ? current.index : 0;\n    var route = current.routes[index];\n    var pattern = void 0;\n\n    var currentParams = _objectSpread({}, route.params);\n\n    var currentOptions = configs;\n    var nestedRouteNames = [];\n    var hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        (function () {\n          var stringify = (_currentOptions$route = currentOptions[route.name]) === null || _currentOptions$route === void 0 ? void 0 : _currentOptions$route.stringify;\n          currentParams = Object.fromEntries(Object.entries(route.params).map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                key = _ref2[0],\n                value = _ref2[1];\n\n            return [key, (stringify === null || stringify === void 0 ? void 0 : stringify[key]) ? stringify[key](value) : String(value)];\n          }));\n\n          if (pattern) {\n            _extends(allParams, currentParams);\n          }\n        })();\n      }\n\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        var nextRoute = route.state.routes[index];\n        var nestedConfig = currentOptions[route.name].screens;\n\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern.split('/').map(function (p) {\n        var name = p.replace(/^:/, '').replace(/\\?$/, '');\n\n        if (p.startsWith(':')) {\n          var value = allParams[name];\n\n          if (currentParams) {\n            delete currentParams[name];\n          }\n\n          if (value === undefined && p.endsWith('?')) {\n            return '';\n          }\n\n          return encodeURIComponent(value);\n        }\n\n        return encodeURIComponent(p);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (currentParams) {\n      for (var param in currentParams) {\n        if (currentParams[param] === 'undefined') {\n          delete currentParams[param];\n        }\n      }\n\n      var query = queryString.stringify(currentParams);\n\n      if (query) {\n        path += \"?\".concat(query);\n      }\n    }\n\n    current = route.state;\n  };\n\n  while (current) {\n    var _currentOptions$route;\n\n    _loop();\n  }\n\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n  return path;\n}\n\nfunction joinPaths() {\n  var _ref3;\n\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n\n  return (_ref3 = []).concat.apply(_ref3, _toConsumableArray(paths.map(function (p) {\n    return p.split('/');\n  }))).filter(Boolean).join('/');\n}\n\nfunction createConfigItem(config, parentPattern) {\n  if (typeof config === 'string') {\n    var _pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return {\n      pattern: _pattern\n    };\n  }\n\n  var pattern = config.exact !== true && parentPattern && config.path ? joinPaths(parentPattern, config.path) : config.path;\n  var screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n  return {\n    pattern: pattern === null || pattern === void 0 ? void 0 : pattern.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens: screens\n  };\n}\n\nfunction createNormalizedConfigs(options, pattern) {\n  return Object.fromEntries(Object.entries(options).map(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n        name = _ref5[0],\n        c = _ref5[1];\n\n    var result = createConfigItem(c, pattern);\n    return [name, result];\n  }));\n}","map":{"version":3,"sources":["getPathFromState.tsx"],"names":["options","state","Error","configs","createNormalizedConfigs","path","current","allParams","index","route","pattern","currentParams","currentOptions","nestedRouteNames","hasNext","stringify","Object","String","nextRoute","nestedConfig","p","name","value","encodeURIComponent","query","queryString","paths","parentPattern","joinPaths","config","screens","result","createConfigItem"],"mappings":"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","sourcesContent":["import queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype OptionsItem = {\n  path?: string;\n  exact?: boolean;\n  stringify?: StringifyConfig;\n  screens?: Options;\n};\n\ntype Options = Record<string, string | OptionsItem>;\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * Example:\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       stringify: { author: author => author.toLowerCase() }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState(\n  state?: State,\n  options: Options = {}\n): string {\n  if (state === undefined) {\n    throw Error('NavigationState not passed');\n  }\n\n  // Create a normalized configs array which will be easier to use\n  const configs = createNormalizedConfigs(options);\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let pattern: string | undefined;\n\n    let currentParams: Record<string, any> = { ...route.params };\n    let currentOptions = configs;\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    let nestedRouteNames = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n\n        currentParams = Object.fromEntries(\n          Object.entries(route.params).map(([key, value]) => [\n            key,\n            stringify?.[key] ? stringify[key](value) : String(value),\n          ])\n        );\n\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number'\n            ? route.state.index\n            : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern\n        .split('/')\n        .map((p) => {\n          const name = p.replace(/^:/, '').replace(/\\?$/, '');\n\n          // If the path has a pattern for a param, put the param in the path\n          if (p.startsWith(':')) {\n            const value = allParams[name];\n\n            // Remove the used value from the params object since we'll use the rest for query string\n            if (currentParams) {\n              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n              delete currentParams[name];\n            }\n\n            if (value === undefined && p.endsWith('?')) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            return encodeURIComponent(value);\n          }\n\n          return encodeURIComponent(p);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (currentParams) {\n      for (let param in currentParams) {\n        if (currentParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete currentParams[param];\n        }\n      }\n\n      const query = queryString.stringify(currentParams);\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  return path;\n}\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\nfunction joinPaths(...paths: string[]): string {\n  return ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n}\n\nfunction createConfigItem(\n  config: OptionsItem | string,\n  parentPattern?: string\n): ConfigItem {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const pattern =\n    config.exact !== true && parentPattern && config.path\n      ? joinPaths(parentPattern, config.path)\n      : config.path;\n\n  const screens = config.screens\n    ? createNormalizedConfigs(config.screens, pattern)\n    : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n  };\n}\n\nfunction createNormalizedConfigs(\n  options: Options,\n  pattern?: string\n): Record<string, ConfigItem> {\n  return Object.fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(c, pattern);\n\n      return [name, result];\n    })\n  );\n}\n"]},"metadata":{},"sourceType":"module"}