{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport RNFetchBlob from \"../index.js\";\nimport Log from \"../utils/log.js\";\nimport fs from \"../fs\";\nimport unicode from \"../utils/unicode\";\nimport Blob from \"./Blob\";\nvar log = new Log('FetchPolyfill');\nlog.disable();\n\nvar Fetch = function Fetch(config) {\n  _classCallCheck(this, Fetch);\n\n  _extends(this, new RNFetchBlobFetchPolyfill(config));\n};\n\nexport { Fetch as default };\n\nvar RNFetchBlobFetchPolyfill = function RNFetchBlobFetchPolyfill(config) {\n  _classCallCheck(this, RNFetchBlobFetchPolyfill);\n\n  this.build = function () {\n    return function (url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var body = options.body;\n      var promise = Promise.resolve();\n      var blobCache = null;\n      options.headers = options.headers || {};\n      var ctype = options['Content-Type'] || options['content-type'];\n      var ctypeH = options.headers['Content-Type'] || options.headers['content-type'];\n      options.headers['Content-Type'] = ctype || ctypeH;\n      options.headers['content-type'] = ctype || ctypeH;\n      options.method = options.method || 'GET';\n\n      if (body) {\n        if (body instanceof FormData) {\n          log.verbose('convert FormData to blob body');\n          promise = Blob.build(body).then(function (b) {\n            blobCache = b;\n            options.headers['Content-Type'] = 'multipart/form-data;boundary=' + b.multipartBoundary;\n            return Promise.resolve(RNFetchBlob.wrap(b._ref));\n          });\n        } else if (body.isRNFetchBlobPolyfill) promise = Promise.resolve(RNFetchBlob.wrap(body.blobPath));else if (typeof body !== 'object' && options.headers['Content-Type'] !== 'application/json') promise = Promise.resolve(JSON.stringify(body));else if (typeof body !== 'string') promise = Promise.resolve(body.toString());else promise = Promise.resolve(body);\n      }\n\n      var progressHandler, uploadHandler, cancelHandler;\n      var statefulPromise = promise.then(function (body) {\n        var task = RNFetchBlob.config(config).fetch(options.method, url, options.headers, body);\n        if (progressHandler) task.progress(progressHandler);\n        if (uploadHandler) task.uploadProgress(uploadHandler);\n        if (cancelHandler) task.cancel();\n        return task.then(function (resp) {\n          log.verbose('response', resp);\n          if (blobCache !== null && blobCache instanceof Blob) blobCache.close();\n          return Promise.resolve(new RNFetchBlobFetchRepsonse(resp));\n        });\n      });\n\n      statefulPromise.progress = function (fn) {\n        progressHandler = fn;\n      };\n\n      statefulPromise.uploadProgress = function (fn) {\n        uploadHandler = fn;\n      };\n\n      statefulPromise.cancel = function () {\n        cancelHandler = true;\n        if (task.cancel) task.cancel();\n      };\n\n      return statefulPromise;\n    };\n  };\n};\n\nvar RNFetchBlobFetchRepsonse = function () {\n  function RNFetchBlobFetchRepsonse(resp) {\n    _classCallCheck(this, RNFetchBlobFetchRepsonse);\n\n    var info = resp.info();\n    this.headers = info.headers;\n    this.ok = info.status >= 200 && info.status <= 299, this.status = info.status;\n    this.type = 'basic';\n    this.bodyUsed = false;\n    this.resp = resp;\n    this.rnfbRespInfo = info;\n    this.rnfbResp = resp;\n  }\n\n  _createClass(RNFetchBlobFetchRepsonse, [{\n    key: \"rawResp\",\n    value: function rawResp() {\n      return Promise.resolve(this.rnfbResp);\n    }\n  }, {\n    key: \"arrayBuffer\",\n    value: function arrayBuffer() {\n      log.verbose('to arrayBuffer', this.rnfbRespInfo);\n      this.bodyUsed = true;\n      return readArrayBuffer(this.rnfbResp, this.rnfbRespInfo);\n    }\n  }, {\n    key: \"text\",\n    value: function text() {\n      log.verbose('to text', this.rnfbResp, this.rnfbRespInfo);\n      this.bodyUsed = true;\n      return readText(this.rnfbResp, this.rnfbRespInfo);\n    }\n  }, {\n    key: \"json\",\n    value: function json() {\n      log.verbose('to json', this.rnfbResp, this.rnfbRespInfo);\n      this.bodyUsed = true;\n      return readJSON(this.rnfbResp, this.rnfbRespInfo);\n    }\n  }, {\n    key: \"blob\",\n    value: function blob() {\n      log.verbose('to blob', this.rnfbResp, this.rnfbRespInfo);\n      this.bodyUsed = true;\n      return readBlob(this.rnfbResp, this.rnfbRespInfo);\n    }\n  }]);\n\n  return RNFetchBlobFetchRepsonse;\n}();\n\nfunction readArrayBuffer(resp, info) {\n  switch (info.rnfbEncode) {\n    case 'path':\n      return resp.readFile('ascii');\n      break;\n\n    default:\n      var buffer = [];\n      var str = resp.text();\n\n      for (var i in str) {\n        buffer[i] = str.charCodeAt(i);\n      }\n\n      return Promise.resolve(buffer);\n      break;\n  }\n}\n\nfunction readText(resp, info) {\n  switch (info.rnfbEncode) {\n    case 'base64':\n      return Promise.resolve(resp.text());\n      break;\n\n    case 'path':\n      return resp.text();\n      break;\n\n    default:\n      return Promise.resolve(resp.text());\n      break;\n  }\n}\n\nfunction readBlob(resp, info) {\n  log.verbose('readBlob', resp, info);\n  return resp.blob();\n}\n\nfunction readJSON(resp, info) {\n  log.verbose('readJSON', resp, info);\n\n  switch (info.rnfbEncode) {\n    case 'base64':\n      return Promise.resolve(resp.json());\n\n    case 'path':\n      return resp.json();\n\n    default:\n      return Promise.resolve(resp.json());\n  }\n}","map":{"version":3,"sources":["/home/thecoder/Documentos/votark/votark/node_modules/react-native-fetch-blob/polyfill/Fetch.js"],"names":["RNFetchBlob","Log","fs","unicode","Blob","log","disable","Fetch","config","RNFetchBlobFetchPolyfill","build","url","options","body","promise","Promise","resolve","blobCache","headers","ctype","ctypeH","method","FormData","verbose","then","b","multipartBoundary","wrap","_ref","isRNFetchBlobPolyfill","blobPath","JSON","stringify","toString","progressHandler","uploadHandler","cancelHandler","statefulPromise","task","fetch","progress","uploadProgress","cancel","resp","close","RNFetchBlobFetchRepsonse","fn","info","ok","status","type","bodyUsed","rnfbRespInfo","rnfbResp","readArrayBuffer","readText","readJSON","readBlob","rnfbEncode","readFile","buffer","str","text","i","charCodeAt","blob","json"],"mappings":"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","sourcesContent":["import RNFetchBlob from '../index.js'\nimport Log from '../utils/log.js'\nimport fs from '../fs'\nimport unicode from '../utils/unicode'\nimport Blob from './Blob'\n\nconst log = new Log('FetchPolyfill')\n\nlog.disable()\n// log.level(3)\n\nexport default class Fetch {\n\n  constructor(config:RNFetchBlobConfig) {\n    Object.assign(this, new RNFetchBlobFetchPolyfill(config))\n  }\n\n}\n\nclass RNFetchBlobFetchPolyfill {\n\n  constructor(config:RNFetchBlobConfig) {\n    this.build = () => (url, options = {}) => {\n\n      let body = options.body\n      let promise = Promise.resolve()\n      let blobCache = null\n\n      options.headers = options.headers || {}\n      let ctype = options['Content-Type'] || options['content-type']\n      let ctypeH = options.headers['Content-Type'] || options.headers['content-type']\n      options.headers['Content-Type'] = ctype || ctypeH\n      options.headers['content-type'] = ctype || ctypeH\n      options.method = options.method || 'GET'\n      if(body) {\n        // When the request body is an instance of FormData, create a Blob cache\n        // to upload the body.\n        if(body instanceof FormData) {\n          log.verbose('convert FormData to blob body')\n          promise = Blob.build(body).then((b) => {\n            blobCache = b\n            options.headers['Content-Type'] = 'multipart/form-data;boundary=' + b.multipartBoundary\n            return Promise.resolve(RNFetchBlob.wrap(b._ref))\n          })\n        }\n        // When request body is a Blob, use file URI of the Blob as request body.\n        else if (body.isRNFetchBlobPolyfill)\n          promise = Promise.resolve(RNFetchBlob.wrap(body.blobPath))\n        else if (typeof body !== 'object' && options.headers['Content-Type'] !== 'application/json')\n          promise = Promise.resolve(JSON.stringify(body))\n        else if (typeof body !== 'string')\n          promise = Promise.resolve(body.toString())\n        // send it as-is, leave the native module decide how to send the body.\n        else\n          promise = Promise.resolve(body)\n      }\n      // task is a progress reportable and cancellable Promise, however,\n      // task.then is not, so we have to extend task.then with progress and\n      // cancel function\n      let progressHandler, uploadHandler, cancelHandler\n      let statefulPromise = promise\n          .then((body) => {\n            let task = RNFetchBlob.config(config)\n              .fetch(options.method, url, options.headers, body)\n            if(progressHandler)\n              task.progress(progressHandler)\n            if(uploadHandler)\n              task.uploadProgress(uploadHandler)\n            if(cancelHandler)\n              task.cancel()\n            return task.then((resp) => {\n              log.verbose('response', resp)\n              // release blob cache created when sending request\n              if(blobCache !== null && blobCache instanceof Blob)\n                blobCache.close()\n              return Promise.resolve(new RNFetchBlobFetchRepsonse(resp))\n            })\n          })\n\n      // extend task.then progress with report and cancelling functions\n      statefulPromise.progress = (fn) => {\n        progressHandler = fn\n      }\n      statefulPromise.uploadProgress = (fn) => {\n        uploadHandler = fn\n      }\n      statefulPromise.cancel = () => {\n        cancelHandler = true\n        if(task.cancel)\n          task.cancel()\n      }\n\n      return statefulPromise\n\n    }\n  }\n\n}\n\nclass RNFetchBlobFetchRepsonse {\n\n  constructor(resp:FetchBlobResponse) {\n    let info = resp.info()\n    this.headers = info.headers\n    this.ok = info.status >= 200 && info.status <= 299,\n    this.status = info.status\n    this.type = 'basic'\n    this.bodyUsed = false\n    this.resp = resp\n    this.rnfbRespInfo = info\n    this.rnfbResp = resp\n  }\n\n  rawResp() {\n    return Promise.resolve(this.rnfbResp)\n  }\n\n  arrayBuffer(){\n    log.verbose('to arrayBuffer', this.rnfbRespInfo)\n    this.bodyUsed = true\n    return readArrayBuffer(this.rnfbResp, this.rnfbRespInfo)\n  }\n\n  text() {\n    log.verbose('to text', this.rnfbResp, this.rnfbRespInfo)\n    this.bodyUsed = true\n    return readText(this.rnfbResp, this.rnfbRespInfo)\n  }\n\n  json() {\n    log.verbose('to json', this.rnfbResp, this.rnfbRespInfo)\n    this.bodyUsed = true\n    return readJSON(this.rnfbResp, this.rnfbRespInfo)\n  }\n\n  blob() {\n    log.verbose('to blob', this.rnfbResp, this.rnfbRespInfo)\n    this.bodyUsed = true\n    return readBlob(this.rnfbResp, this.rnfbRespInfo)\n  }\n}\n\n/**\n * Get response data as array.\n * @param  {FetchBlobResponse} resp Response data object from RNFB fetch call.\n * @param  {RNFetchBlobResponseInfo} info Response informations.\n * @return {Promise<Array>}\n */\nfunction readArrayBuffer(resp, info):Promise<Array> {\n  switch (info.rnfbEncode) {\n    case 'path':\n      return resp.readFile('ascii')\n      break\n    default:\n      let buffer = []\n      let str = resp.text()\n      for (let i in str) {\n        buffer[i] = str.charCodeAt(i);\n      }\n      return Promise.resolve(buffer)\n      break\n  }\n}\n\n/**\n * Get response data as string.\n * @param  {FetchBlobResponse} resp Response data object from RNFB fetch call.\n * @param  {RNFetchBlobResponseInfo} info Response informations.\n * @return {Promise<string>}\n */\nfunction readText(resp, info):Promise<string> {\n  switch (info.rnfbEncode) {\n    case 'base64':\n      return Promise.resolve(resp.text())\n      break\n    case 'path':\n      return resp.text()\n      break\n    default:\n      return Promise.resolve(resp.text())\n      break\n  }\n}\n\n\n/**\n * Get response data as RNFetchBlob Blob polyfill object.\n * @param  {FetchBlobResponse} resp Response data object from RNFB fetch call.\n * @param  {RNFetchBlobResponseInfo} info Response informations.\n * @return {Promise<Blob>}\n */\nfunction readBlob(resp, info):Promise<Blob> {\n  log.verbose('readBlob', resp, info)\n  return resp.blob()\n}\n\n/**\n * Get response data as JSON object.\n * @param  {FetchBlobResponse} resp Response data object from RNFB fetch call.\n * @param  {RNFetchBlobResponseInfo} info Response informations.\n * @return {Promise<object>}\n */\nfunction readJSON(resp, info):Promise<object> {\n  log.verbose('readJSON', resp, info)\n  switch (info.rnfbEncode) {\n    case 'base64':\n      return Promise.resolve(resp.json())\n    case 'path':\n      return resp.json()\n    default:\n      return Promise.resolve(resp.json())\n  }\n}\n"]},"metadata":{},"sourceType":"module"}