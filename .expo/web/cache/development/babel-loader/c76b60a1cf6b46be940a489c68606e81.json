{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport RNFetchBlob from \"../index.js\";\nimport fs from \"../fs.js\";\nimport getUUID from \"../utils/uuid\";\nimport Log from \"../utils/log.js\";\nimport EventTarget from \"./EventTarget\";\nvar log = new Log('Blob');\nvar blobCacheDir = fs.dirs.DocumentDir + '/RNFetchBlob-blobs/';\nlog.disable();\n\nvar Blob = function (_EventTarget) {\n  _inherits(Blob, _EventTarget);\n\n  var _super = _createSuper(Blob);\n\n  _createClass(Blob, [{\n    key: \"blobPath\",\n    get: function get() {\n      return this._ref;\n    }\n  }], [{\n    key: \"clearCache\",\n    value: function clearCache() {\n      return fs.unlink(blobCacheDir).then(function () {\n        return fs.mkdir(blobCacheDir);\n      });\n    }\n  }, {\n    key: \"build\",\n    value: function build(data, cType) {\n      return new Promise(function (resolve, reject) {\n        new Blob(data, cType).onCreated(resolve);\n      });\n    }\n  }, {\n    key: \"setLog\",\n    value: function setLog(level) {\n      if (level === -1) log.disable();else log.level(level);\n    }\n  }]);\n\n  function Blob(data, cType, defer) {\n    var _this;\n\n    _classCallCheck(this, Blob);\n\n    _this = _super.call(this);\n    _this.isRNFetchBlobPolyfill = true;\n    _this.multipartBoundary = null;\n    _this._ref = null;\n    _this._blobCreated = false;\n    _this._onCreated = [];\n    _this._closed = false;\n    cType = cType || {};\n    _this.cacheName = getBlobName();\n    _this.isRNFetchBlobPolyfill = true;\n    _this.isDerived = defer;\n    _this.type = cType.type || 'text/plain';\n    log.verbose('Blob constructor called', 'mime', _this.type, 'type', typeof data, 'length', data ? data.length : 0);\n    _this._ref = blobCacheDir + _this.cacheName;\n    var p = null;\n    if (!data) data = '';\n\n    if (data.isRNFetchBlobPolyfill) {\n      log.verbose('create Blob cache file from Blob object');\n      var size = 0;\n      _this._ref = String(data.getRNFetchBlobRef());\n      var orgPath = _this._ref;\n      p = fs.exists(orgPath).then(function (exist) {\n        if (exist) return fs.writeFile(orgPath, data, 'uri').then(function (size) {\n          return Promise.resolve(size);\n        }).catch(function (err) {\n          throw \"RNFetchBlob Blob file creation error, \" + err;\n        });else throw \"could not create Blob from path \" + orgPath + \", file not exists\";\n      });\n    } else if (data instanceof FormData) {\n        log.verbose('create Blob cache file from FormData', data);\n        var boundary = \"RNFetchBlob-\" + _this.cacheName + \"-\" + Date.now();\n        _this.multipartBoundary = boundary;\n        var parts = data.getParts();\n        var formArray = [];\n\n        if (!parts) {\n          p = fs.writeFile(_this._ref, '', 'utf8');\n        } else {\n          for (var i in parts) {\n            formArray.push('\\r\\n--' + boundary + '\\r\\n');\n            var part = parts[i];\n\n            for (var j in part.headers) {\n              formArray.push(j + ': ' + part.headers[j] + '\\r\\n');\n            }\n\n            formArray.push('\\r\\n');\n            if (part.isRNFetchBlobPolyfill) formArray.push(part);else formArray.push(part.string);\n          }\n\n          log.verbose('FormData array', formArray);\n          formArray.push('\\r\\n--' + boundary + '--\\r\\n');\n          p = createMixedBlobData(_this._ref, formArray);\n        }\n      } else if (typeof data === 'string' && data.startsWith('RNFetchBlob-file://')) {\n          log.verbose('create Blob cache file from file path', data);\n          _this._isReference = true;\n          _this._ref = String(data).replace('RNFetchBlob-file://', '');\n          var _orgPath = _this._ref;\n          if (defer) return _possibleConstructorReturn(_this);else {\n            p = fs.stat(_orgPath).then(function (stat) {\n              return Promise.resolve(stat.size);\n            });\n          }\n        } else if (typeof data === 'string') {\n            var encoding = 'utf8';\n            var mime = String(_this.type);\n            if (/(application\\/octet|\\;base64)/i.test(mime)) encoding = 'base64';else data = data.toString();\n            _this.type = String(_this.type).replace(/;base64/ig, '');\n            log.verbose('create Blob cache file from string', 'encode', encoding);\n            p = fs.writeFile(_this._ref, data, encoding).then(function (size) {\n              return Promise.resolve(size);\n            });\n          } else if (Array.isArray(data)) {\n              log.verbose('create Blob cache file from mixed array', data);\n              p = createMixedBlobData(_this._ref, data);\n            } else {\n              data = data.toString();\n              p = fs.writeFile(_this._ref, data, 'utf8').then(function (size) {\n                return Promise.resolve(size);\n              });\n            }\n\n    p && p.then(function (size) {\n      _this.size = size;\n\n      _this._invokeOnCreateEvent();\n    }).catch(function (err) {\n      log.error('RNFetchBlob could not create Blob : ' + _this._ref, err);\n    });\n    return _this;\n  }\n\n  _createClass(Blob, [{\n    key: \"onCreated\",\n    value: function onCreated(fn) {\n      log.verbose('#register blob onCreated', this._blobCreated);\n      if (!this._blobCreated) this._onCreated.push(fn);else {\n        fn(this);\n      }\n      return this;\n    }\n  }, {\n    key: \"markAsDerived\",\n    value: function markAsDerived() {\n      this._isDerived = true;\n    }\n  }, {\n    key: \"getRNFetchBlobRef\",\n    value: function getRNFetchBlobRef() {\n      return this._ref;\n    }\n  }, {\n    key: \"slice\",\n    value: function slice(start, end) {\n      var _this2 = this;\n\n      var contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      if (this._closed) throw 'Blob has been released.';\n      log.verbose('slice called', start, end, contentType);\n      var resPath = blobCacheDir + getBlobName();\n      var pass = false;\n      log.debug('fs.slice new blob will at', resPath);\n      var result = new Blob(RNFetchBlob.wrap(resPath), {\n        type: contentType\n      }, true);\n      fs.exists(blobCacheDir).then(function (exist) {\n        if (exist) return Promise.resolve();\n        return fs.mkdir(blobCacheDir);\n      }).then(function () {\n        return fs.slice(_this2._ref, resPath, start, end);\n      }).then(function (dest) {\n        log.debug('fs.slice done', dest);\n\n        result._invokeOnCreateEvent();\n\n        pass = true;\n      }).catch(function (err) {\n        console.warn('Blob.slice failed:', err);\n        pass = true;\n      });\n      log.debug('slice returning new Blob');\n      return result;\n    }\n  }, {\n    key: \"readBlob\",\n    value: function readBlob(encoding) {\n      if (this._closed) throw 'Blob has been released.';\n      return fs.readFile(this._ref, encoding || 'utf8');\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._closed) return Promise.reject('Blob has been released.');\n      this._closed = true;\n      return fs.unlink(this._ref).catch(function (err) {\n        console.warn(err);\n      });\n    }\n  }, {\n    key: \"safeClose\",\n    value: function safeClose() {\n      if (this._closed) return Promise.reject('Blob has been released.');\n      this._closed = true;\n\n      if (!this._isReference) {\n        return fs.unlink(this._ref).catch(function (err) {\n          console.warn(err);\n        });\n      } else {\n        return Promise.resolve();\n      }\n    }\n  }, {\n    key: \"_invokeOnCreateEvent\",\n    value: function _invokeOnCreateEvent() {\n      log.verbose('invoke create event', this._onCreated);\n      this._blobCreated = true;\n      var fns = this._onCreated;\n\n      for (var i in fns) {\n        if (typeof fns[i] === 'function') {\n          fns[i](this);\n        }\n      }\n\n      delete this._onCreated;\n    }\n  }, {\n    key: \"isDerived\",\n    get: function get() {\n      return this._isDerived || false;\n    }\n  }]);\n\n  return Blob;\n}(EventTarget);\n\nexport { Blob as default };\n\nfunction getBlobName() {\n  return 'blob-' + getUUID();\n}\n\nfunction createMixedBlobData(ref, dataArray) {\n  var p = fs.writeFile(ref, '');\n  var args = [];\n  var size = 0;\n\n  for (var i in dataArray) {\n    var part = dataArray[i];\n    if (!part) continue;\n\n    if (part.isRNFetchBlobPolyfill) {\n      args.push([ref, part._ref, 'uri']);\n    } else if (typeof part === 'string') args.push([ref, part, 'utf8']);else if (Array.isArray(part)) args.push([ref, part, 'ascii']);\n  }\n\n  var _loop = function _loop(_i) {\n    p = p.then(function (written) {\n      var arg = this;\n      if (written) size += written;\n      log.verbose('mixed blob write', args[_i], written);\n      return fs.appendFile.apply(fs, _toConsumableArray(arg));\n    }.bind(args[_i]));\n  };\n\n  for (var _i in args) {\n    _loop(_i);\n  }\n\n  return p.then(function () {\n    return Promise.resolve(size);\n  });\n}","map":{"version":3,"sources":["/home/thecoder/Documentos/votark/votark/node_modules/react-native-fetch-blob/polyfill/Blob.js"],"names":["RNFetchBlob","fs","getUUID","Log","EventTarget","log","blobCacheDir","dirs","DocumentDir","disable","Blob","_ref","unlink","then","mkdir","data","cType","Promise","resolve","reject","onCreated","level","defer","isRNFetchBlobPolyfill","multipartBoundary","_blobCreated","_onCreated","_closed","cacheName","getBlobName","isDerived","type","verbose","length","p","size","String","getRNFetchBlobRef","orgPath","exists","exist","writeFile","catch","err","FormData","boundary","Date","now","parts","getParts","formArray","i","push","part","j","headers","string","createMixedBlobData","startsWith","_isReference","replace","stat","encoding","mime","test","toString","Array","isArray","_invokeOnCreateEvent","error","fn","_isDerived","start","end","contentType","resPath","pass","debug","result","wrap","slice","dest","console","warn","readFile","fns","ref","dataArray","args","written","arg","appendFile","bind"],"mappings":"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","sourcesContent":["// Copyright 2016 wkh237@github. All rights reserved.\n// Use of this source code is governed by a MIT-style license that can be\n// found in the LICENSE file.\n\nimport RNFetchBlob from '../index.js'\nimport fs from '../fs.js'\nimport getUUID from '../utils/uuid'\nimport Log from '../utils/log.js'\nimport EventTarget from './EventTarget'\n\nconst log = new Log('Blob')\nconst blobCacheDir = fs.dirs.DocumentDir + '/RNFetchBlob-blobs/'\n\nlog.disable()\n// log.level(3)\n\n/**\n * A RNFetchBlob style Blob polyfill class, this is a Blob which compatible to\n * Response object attain fron RNFetchBlob.fetch.\n */\nexport default class Blob extends EventTarget {\n\n  cacheName:string;\n  type:string;\n  size:number;\n  isRNFetchBlobPolyfill:boolean = true;\n  multipartBoundary:string = null;\n\n  _ref:string = null;\n  _blobCreated:boolean = false;\n  _onCreated:Array<any> = [];\n  _closed:boolean = false;\n\n  /**\n   * Static method that remove all files in Blob cache folder.\n   * @nonstandard\n   * @return {Promise}\n   */\n  static clearCache() {\n    return fs.unlink(blobCacheDir).then(() => fs.mkdir(blobCacheDir))\n  }\n\n  static build(data:any, cType:any):Promise<Blob> {\n    return new Promise((resolve, reject) => {\n      new Blob(data, cType).onCreated(resolve)\n    })\n  }\n\n  get blobPath() {\n    return this._ref\n  }\n\n  static setLog(level:number) {\n    if(level === -1)\n      log.disable()\n    else\n      log.level(level)\n  }\n\n  /**\n   * RNFetchBlob Blob polyfill, create a Blob directly from file path, BASE64\n   * encoded data, and string. The conversion is done implicitly according to\n   * given `mime`. However, the blob creation is asynchronously, to register\n   * event `onCreated` is need to ensure the Blob is creadted.\n   * @param  {any} data Content of Blob object\n   * @param  {any} mime Content type settings of Blob object, `text/plain`\n   *                    by default\n   * @param  {boolean} defer When this argument set to `true`, blob constructor\n   *                         will not invoke blob created event automatically.\n   */\n  constructor(data:any, cType:any, defer:boolean) {\n    super()\n    cType = cType || {}\n    this.cacheName = getBlobName()\n    this.isRNFetchBlobPolyfill = true\n    this.isDerived = defer\n    this.type = cType.type || 'text/plain'\n    log.verbose('Blob constructor called', 'mime', this.type, 'type', typeof data, 'length', data?  data.length:0)\n    this._ref = blobCacheDir + this.cacheName\n    let p = null\n    if(!data)\n      data = ''\n    if(data.isRNFetchBlobPolyfill) {\n      log.verbose('create Blob cache file from Blob object')\n      let size = 0\n      this._ref = String(data.getRNFetchBlobRef())\n      let orgPath = this._ref\n\n      p = fs.exists(orgPath)\n            .then((exist) =>  {\n              if(exist)\n                return fs.writeFile(orgPath, data, 'uri')\n                         .then((size) => Promise.resolve(size))\n                         .catch((err) => {\n                           throw `RNFetchBlob Blob file creation error, ${err}`\n                         })\n              else\n                throw `could not create Blob from path ${orgPath}, file not exists`\n            })\n    }\n    // process FormData\n    else if(data instanceof FormData) {\n      log.verbose('create Blob cache file from FormData', data)\n      let boundary = `RNFetchBlob-${this.cacheName}-${Date.now()}`\n      this.multipartBoundary = boundary\n      let parts = data.getParts()\n      let formArray = []\n      if(!parts) {\n        p = fs.writeFile(this._ref, '', 'utf8')\n      }\n      else {\n        for(let i in parts) {\n          formArray.push('\\r\\n--'+boundary+'\\r\\n')\n          let part = parts[i]\n          for(let j in part.headers) {\n            formArray.push(j + ': ' +part.headers[j] + '\\r\\n')\n          }\n          formArray.push('\\r\\n')\n          if(part.isRNFetchBlobPolyfill)\n            formArray.push(part)\n          else\n            formArray.push(part.string)\n        }\n        log.verbose('FormData array', formArray)\n        formArray.push('\\r\\n--'+boundary+'--\\r\\n')\n        p = createMixedBlobData(this._ref, formArray)\n      }\n    }\n    // if the data is a string starts with `RNFetchBlob-file://`, append the\n    // Blob data from file path\n    else if(typeof data === 'string' && data.startsWith('RNFetchBlob-file://')) {\n      log.verbose('create Blob cache file from file path', data)\n      // set this flag so that we know this blob is a wrapper of an existing file\n      this._isReference = true\n      this._ref = String(data).replace('RNFetchBlob-file://', '')\n      let orgPath = this._ref\n      if(defer)\n        return\n      else {\n        p = fs.stat(orgPath)\n              .then((stat) =>  {\n                return Promise.resolve(stat.size)\n              })\n      }\n    }\n    // content from variable need create file\n    else if(typeof data === 'string') {\n      let encoding = 'utf8'\n      let mime = String(this.type)\n      // when content type contains application/octet* or *;base64, RNFetchBlob\n      // fs will treat it as BASE64 encoded string binary data\n      if(/(application\\/octet|\\;base64)/i.test(mime))\n        encoding = 'base64'\n      else\n        data = data.toString()\n      // create cache file\n      this.type = String(this.type).replace(/;base64/ig, '')\n      log.verbose('create Blob cache file from string', 'encode', encoding)\n      p = fs.writeFile(this._ref, data, encoding)\n            .then((size) => {\n              return Promise.resolve(size)\n            })\n\n    }\n    // TODO : ArrayBuffer support\n    // else if (data instanceof ArrayBuffer ) {\n    //\n    // }\n    // when input is an array of mixed data types, create a file cache\n    else if(Array.isArray(data)) {\n      log.verbose('create Blob cache file from mixed array', data)\n      p = createMixedBlobData(this._ref, data)\n    }\n    else {\n      data = data.toString()\n      p = fs.writeFile(this._ref, data, 'utf8')\n            .then((size) => Promise.resolve(size))\n    }\n    p && p.then((size) => {\n      this.size = size\n      this._invokeOnCreateEvent()\n    })\n    .catch((err) => {\n      log.error('RNFetchBlob could not create Blob : '+ this._ref, err)\n    })\n\n  }\n\n  /**\n   * Since Blob content will asynchronously write to a file during creation,\n   * use this method to register an event handler for Blob initialized event.\n   * @nonstandard\n   * @param  {(b:Blob) => void} An event handler invoked when Blob created\n   * @return {Blob} The Blob object instance itself\n   */\n  onCreated(fn:() => void):Blob {\n    log.verbose('#register blob onCreated', this._blobCreated)\n    if(!this._blobCreated)\n      this._onCreated.push(fn)\n    else {\n      fn(this)\n    }\n    return this\n  }\n\n  markAsDerived() {\n    this._isDerived = true\n  }\n\n  get isDerived() {\n    return this._isDerived || false\n  }\n\n  /**\n   * Get file reference of the Blob object.\n   * @nonstandard\n   * @return {string} Blob file reference which can be consumed by RNFetchBlob fs\n   */\n  getRNFetchBlobRef() {\n    return this._ref\n  }\n\n  /**\n   * Create a Blob object which is sliced from current object\n   * @param  {number} start    Start byte number\n   * @param  {number} end      End byte number\n   * @param  {string} contentType Optional, content type of new Blob object\n   * @return {Blob}\n   */\n  slice(start:?number, end:?number, contentType:?string=''):Blob {\n    if(this._closed)\n      throw 'Blob has been released.'\n    log.verbose('slice called', start, end, contentType)\n\n\n    let resPath = blobCacheDir + getBlobName()\n    let pass = false\n    log.debug('fs.slice new blob will at', resPath)\n    let result = new Blob(RNFetchBlob.wrap(resPath), { type : contentType }, true)\n    fs.exists(blobCacheDir)\n    .then((exist) => {\n      if(exist)\n        return Promise.resolve()\n      return fs.mkdir(blobCacheDir)\n    })\n    .then(() => fs.slice(this._ref, resPath, start, end))\n    .then((dest) => {\n      log.debug('fs.slice done', dest)\n      result._invokeOnCreateEvent()\n      pass = true\n    })\n    .catch((err) => {\n      console.warn('Blob.slice failed:', err)\n      pass = true\n    })\n    log.debug('slice returning new Blob')\n\n    return result\n  }\n\n  /**\n   * Read data of the Blob object, this is not standard method.\n   * @nonstandard\n   * @param  {string} encoding Read data with encoding\n   * @return {Promise}\n   */\n  readBlob(encoding:string):Promise<any> {\n    if(this._closed)\n      throw 'Blob has been released.'\n    return fs.readFile(this._ref, encoding || 'utf8')\n  }\n\n  /**\n   * Release the resource of the Blob object.\n   * @nonstandard\n   * @return {Promise}\n   */\n  close() {\n    if(this._closed)\n      return Promise.reject('Blob has been released.')\n    this._closed = true\n    return fs.unlink(this._ref).catch((err) => {\n      console.warn(err)\n    })\n  }\n\n  safeClose() {\n    if(this._closed)\n      return Promise.reject('Blob has been released.')\n    this._closed = true\n    if(!this._isReference) {\n      return fs.unlink(this._ref).catch((err) => {\n        console.warn(err)\n      })   \n    }\n    else {\n      return Promise.resolve()\n    }\n  }\n\n  _invokeOnCreateEvent() {\n    log.verbose('invoke create event', this._onCreated)\n    this._blobCreated = true\n    let fns = this._onCreated\n    for(let i in fns) {\n      if(typeof fns[i] === 'function') {\n        fns[i](this)\n      }\n    }\n    delete this._onCreated\n  }\n\n}\n\n/**\n * Get a temp filename for Blob object\n * @return {string} Temporary filename\n */\nfunction getBlobName() {\n  return 'blob-' + getUUID()\n}\n\n/**\n * Create a file according to given array. The element in array can be a number,\n * Blob, String, Array.\n * @param  {string} ref File path reference\n * @param  {Array} dataArray An array contains different types of data.\n * @return {Promise}\n */\nfunction createMixedBlobData(ref, dataArray) {\n  // create an empty file for store blob data\n  let p = fs.writeFile(ref, '')\n  let args = []\n  let size = 0\n  for(let i in dataArray) {\n    let part = dataArray[i]\n    if(!part)\n      continue\n    if(part.isRNFetchBlobPolyfill) {\n      args.push([ref, part._ref, 'uri'])\n    }\n    else if(typeof part === 'string')\n      args.push([ref, part, 'utf8'])\n    // TODO : ArrayBuffer\n    // else if (part instanceof ArrayBuffer) {\n    //\n    // }\n    else if (Array.isArray(part))\n      args.push([ref, part, 'ascii'])\n  }\n  // start write blob data\n  for(let i in args) {\n    p = p.then(function(written){\n      let arg = this\n      if(written)\n        size += written\n      log.verbose('mixed blob write', args[i], written)\n      return fs.appendFile(...arg)\n    }.bind(args[i]))\n  }\n  return p.then(() => Promise.resolve(size))\n}\n"]},"metadata":{},"sourceType":"module"}