{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar RNFetchBlob = require('react-native-fetch-blob').default;\n\nvar fs = RNFetchBlob.fs;\nvar activeDownloads = {};\n\nfunction getDirPath(path) {\n  if (path.charAt(path.length - 4) === '.' || path.charAt(path.length - 5) === '.') {\n    return _.initial(path.split('/')).join('/');\n  }\n\n  return path;\n}\n\nfunction ensurePath(path) {\n  var dirPath = getDirPath(path);\n  return fs.isDir(dirPath).then(function (isDir) {\n    if (!isDir) {\n      return fs.mkdir(dirPath).then(function () {\n        return fs.isDir(dirPath);\n      }).then(function (isDir) {\n        if (!isDir) {\n          throw new Error('Invalid cacheLocation');\n        }\n      });\n    }\n  }).catch(function (err) {\n    if (err.message.includes('folder already exists')) {\n      return;\n    }\n\n    throw err;\n  });\n}\n\nfunction collectFilesInfo(basePath) {\n  return fs.stat(basePath).then(function (info) {\n    if (info.type === 'file') {\n      return [info];\n    }\n\n    return fs.ls(basePath).then(function (files) {\n      var promises = _.map(files, function (file) {\n        return collectFilesInfo(basePath + \"/\" + file);\n      });\n\n      return Promise.all(promises);\n    });\n  }).catch(function (err) {\n    return [];\n  });\n}\n\nmodule.exports = {\n  getCacheDir: function getCacheDir() {\n    return fs.dirs.CacheDir + '/imagesCacheDir';\n  },\n  downloadFile: function downloadFile(fromUrl, toFile, headers) {\n    var _this = this;\n\n    if (!_.has(activeDownloads, toFile)) {\n      var tmpFile = toFile + '.tmp';\n      activeDownloads[toFile] = ensurePath(toFile).then(function () {\n        return RNFetchBlob.config({\n          path: tmpFile\n        }).fetch('GET', fromUrl, headers).then(function (res) {\n          if (res.respInfo.status === 304) {\n            return Promise.resolve(toFile);\n          }\n\n          var status = Math.floor(res.respInfo.status / 100);\n\n          if (status !== 2) {\n            return Promise.reject();\n          }\n\n          return RNFetchBlob.fs.stat(tmpFile).then(function (fileStats) {\n            if (res.respInfo.headers['Content-Length'] && res.respInfo.headers['Content-Length'] != fileStats.size) {\n              return Promise.reject();\n            }\n\n            return fs.mv(tmpFile, toFile);\n          });\n        }).catch(function (error) {\n          _this.deleteFile(tmpFile);\n\n          delete activeDownloads[toFile];\n          return Promise.reject('Download failed');\n        }).then(function () {\n          _this.deleteFile(tmpFile);\n\n          delete activeDownloads[toFile];\n          return toFile;\n        });\n      });\n    }\n\n    return activeDownloads[toFile];\n  },\n  deleteFile: function deleteFile(filePath) {\n    return fs.stat(filePath).then(function (res) {\n      return res && res.type === 'file';\n    }).then(function (exists) {\n      return exists && fs.unlink(filePath);\n    }).catch(function (err) {});\n  },\n  copyFile: function copyFile(fromFile, toFile) {\n    return ensurePath(toFile).then(function () {\n      return fs.cp(fromFile, toFile);\n    });\n  },\n  cleanDir: function cleanDir(dirPath) {\n    return fs.isDir(dirPath).then(function (isDir) {\n      return isDir && fs.unlink(dirPath);\n    }).catch(function () {}).then(function () {\n      return ensurePath(dirPath);\n    });\n  },\n  getDirInfo: function getDirInfo(dirPath) {\n    return fs.isDir(dirPath).then(function (isDir) {\n      if (isDir) {\n        return collectFilesInfo(dirPath);\n      } else {\n        throw new Error('Dir does not exists');\n      }\n    }).then(function (filesInfo) {\n      var files = _.flattenDeep(filesInfo);\n\n      var size = _.sumBy(files, 'size');\n\n      return {\n        files: files,\n        size: size\n      };\n    });\n  },\n  exists: function exists(path) {\n    return fs.exists(path);\n  }\n};","map":{"version":3,"sources":["/home/thecoder/Documentos/votark/votark/node_modules/react-native-cached-image/utils/fsUtils.js"],"names":["_","require","RNFetchBlob","default","fs","activeDownloads","getDirPath","path","charAt","length","initial","split","join","ensurePath","dirPath","isDir","then","mkdir","Error","catch","err","message","includes","collectFilesInfo","basePath","stat","info","type","ls","files","promises","map","file","Promise","all","module","exports","getCacheDir","dirs","CacheDir","downloadFile","fromUrl","toFile","headers","has","tmpFile","config","fetch","res","respInfo","status","resolve","Math","floor","reject","fileStats","size","mv","error","deleteFile","filePath","exists","unlink","copyFile","fromFile","cp","cleanDir","getDirInfo","filesInfo","flattenDeep","sumBy"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nconst RNFetchBlob = require('react-native-fetch-blob').default;\n\nconst {\n    fs\n} = RNFetchBlob;\n\nconst activeDownloads = {};\n\nfunction getDirPath(path) {\n    // if path is a file (has ext) remove it\n    if (path.charAt(path.length - 4) === '.' || path.charAt(path.length - 5) === '.') {\n        return _.initial(path.split('/')).join('/');\n    }\n    return path;\n}\n\nfunction ensurePath(path) {\n    const dirPath = getDirPath(path);\n    return fs.isDir(dirPath)\n        .then(isDir => {\n            if (!isDir) {\n                return fs.mkdir(dirPath)\n                    // check if dir has indeed been created because\n                    // there's no exception on incorrect user-defined paths (?)...\n                    .then(() => fs.isDir(dirPath))\n                    .then(isDir => {\n                        if (!isDir) {\n                            throw new Error('Invalid cacheLocation');\n                        }\n                    })\n            }\n        })\n        .catch(err => {\n            // ignore folder already exists errors\n            if (err.message.includes('folder already exists')) {\n                return;\n            }\n            throw err;\n        });\n}\n\nfunction collectFilesInfo(basePath) {\n    return fs.stat(basePath)\n        .then((info) => {\n            if (info.type === 'file') {\n                return [info];\n            }\n            return fs.ls(basePath)\n                .then(files => {\n                    const promises = _.map(files, file => {\n                        return collectFilesInfo(`${basePath}/${file}`);\n                    });\n                    return Promise.all(promises);\n                });\n        })\n        .catch(err => {\n            return [];\n        });\n}\n\n/**\n * wrapper around common filesystem actions\n */\nmodule.exports = {\n\n    /**\n     * returns the local cache dir\n     * @returns {String}\n     */\n    getCacheDir() {\n        return fs.dirs.CacheDir + '/imagesCacheDir';\n    },\n\n    /**\n     * returns a promise that is resolved when the download of the requested file\n     * is complete and the file is saved.\n     * if the download fails, or was stopped the partial file is deleted, and the\n     * promise is rejected\n     * @param fromUrl   String source url\n     * @param toFile    String destination path\n     * @param headers   Object with headers to use when downloading the file\n     * @returns {Promise}\n     */\n    downloadFile(fromUrl, toFile, headers) {\n        // use toFile as the key as is was created using the cacheKey\n        if (!_.has(activeDownloads, toFile)) {\n            // using a temporary file, if the download is accidentally interrupted, it will not produce a disabled file\n            const tmpFile = toFile + '.tmp';\n            // create an active download for this file\n            activeDownloads[toFile] = ensurePath(toFile)\n                .then(() => RNFetchBlob\n                    .config({\n                        path: tmpFile\n                    })\n                    .fetch('GET', fromUrl, headers)\n                    .then(res => {\n                        if (res.respInfo.status === 304) {\n                            return Promise.resolve(toFile);\n                        }\n                        let status = Math.floor(res.respInfo.status / 100);\n                        if (status !== 2) {\n                            // TODO - log / return error?\n                            return Promise.reject();\n                        }\n\n                        return RNFetchBlob.fs.stat(tmpFile)\n                            .then(fileStats => {\n                                // Verify if the content was fully downloaded!\n                                if (res.respInfo.headers['Content-Length'] && res.respInfo.headers['Content-Length'] != fileStats.size) {\n                                    return Promise.reject();\n                                }\n\n                                // the download is complete and rename the temporary file\n                                return fs.mv(tmpFile, toFile);\n                            });\n\n\n                    })\n                    .catch(error => {\n                        // cleanup. will try re-download on next CachedImage mount.\n                        this.deleteFile(tmpFile);\n                        delete activeDownloads[toFile];\n                        return Promise.reject('Download failed');\n                    })\n                    .then(() => {\n                        // cleanup\n                        this.deleteFile(tmpFile);\n                        delete activeDownloads[toFile];\n                        return toFile;\n                    })\n                );\n        }\n        return activeDownloads[toFile];\n    },\n\n    /**\n     * remove the file in filePath if it exists.\n     * this method always resolves\n     * @param filePath\n     * @returns {Promise}\n     */\n    deleteFile(filePath) {\n        return fs.stat(filePath)\n            .then(res => res && res.type === 'file')\n            .then(exists => exists && fs.unlink(filePath))\n            .catch((err) => {\n                // swallow error to always resolve\n            });\n    },\n\n    /**\n     * copy a file from fromFile to toFile\n     * @param fromFile\n     * @param toFile\n     * @returns {Promise}\n     */\n    copyFile(fromFile, toFile) {\n        return ensurePath(toFile)\n            .then(() => fs.cp(fromFile, toFile));\n    },\n\n    /**\n     * remove the contents of dirPath\n     * @param dirPath\n     * @returns {Promise}\n     */\n    cleanDir(dirPath) {\n        return fs.isDir(dirPath)\n            .then(isDir => isDir && fs.unlink(dirPath))\n            .catch(() => {})\n            .then(() => ensurePath(dirPath));\n    },\n\n    /**\n     * get info about files in a folder\n     * @param dirPath\n     * @returns {Promise.<{file:Array, size:Number}>}\n     */\n    getDirInfo(dirPath) {\n        return fs.isDir(dirPath)\n            .then(isDir => {\n                if (isDir) {\n                    return collectFilesInfo(dirPath);\n                } else {\n                    throw new Error('Dir does not exists');\n                }\n            })\n            .then(filesInfo => {\n                const files = _.flattenDeep(filesInfo);\n                const size = _.sumBy(files, 'size');\n                return {\n                    files,\n                    size\n                };\n            });\n    },\n\n    exists(path) {\n        return fs.exists(path);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}