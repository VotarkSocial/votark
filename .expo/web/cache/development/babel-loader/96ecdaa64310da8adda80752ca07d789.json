{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar fsUtils = require(\"./utils/fsUtils\");\n\nvar pathUtils = require(\"./utils/pathUtils\");\n\nvar MemoryCache = require('react-native-clcasher/MemoryCache').default;\n\nmodule.exports = function () {\n  var defaultOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var urlCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MemoryCache;\n  var fs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : fsUtils;\n  var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : pathUtils;\n  var defaultDefaultOptions = {\n    headers: {},\n    ttl: 60 * 60 * 24 * 14,\n    useQueryParamsInCacheKey: false,\n    cacheLocation: fs.getCacheDir(),\n    allowSelfSignedSSL: false\n  };\n\n  _.defaults(defaultOptions, defaultDefaultOptions);\n\n  function isCacheable(url) {\n    return _.isString(url) && (_.startsWith(url.toLowerCase(), 'http://') || _.startsWith(url.toLowerCase(), 'https://'));\n  }\n\n  function cacheUrl(url, options, getCachedFile) {\n    if (!isCacheable(url)) {\n      return Promise.reject(new Error('Url is not cacheable'));\n    }\n\n    _.defaults(options, defaultOptions);\n\n    var cacheableUrl = path.getCacheableUrl(url, options.useQueryParamsInCacheKey);\n    return urlCache.get(cacheableUrl).then(function (fileRelativePath) {\n      if (!fileRelativePath) {\n        throw new Error('URL expired or not in cache');\n      }\n\n      var cachedFilePath = options.cacheLocation + \"/\" + fileRelativePath;\n      return fs.exists(cachedFilePath).then(function (exists) {\n        if (exists) {\n          return cachedFilePath;\n        } else {\n          throw new Error('file under URL stored in url cache doesn\\'t exsts');\n        }\n      });\n    }).catch(function () {\n      var fileRelativePath = path.getImageRelativeFilePath(cacheableUrl);\n      var filePath = options.cacheLocation + \"/\" + fileRelativePath;\n      return fs.deleteFile(filePath).then(function () {\n        return getCachedFile(filePath);\n      }).then(function () {\n        return urlCache.set(cacheableUrl, fileRelativePath, options.ttl);\n      }).then(function () {\n        return filePath;\n      });\n    });\n  }\n\n  return {\n    downloadAndCacheUrl: function downloadAndCacheUrl(url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return cacheUrl(url, options, function (filePath) {\n        return fs.downloadFile(url, filePath, options.headers);\n      });\n    },\n    seedAndCacheUrl: function seedAndCacheUrl(url, seedPath) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return cacheUrl(url, options, function (filePath) {\n        return fs.copyFile(seedPath, filePath);\n      });\n    },\n    deleteUrl: function deleteUrl(url) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!isCacheable(url)) {\n        return Promise.reject(new Error('Url is not cacheable'));\n      }\n\n      _.defaults(options, defaultOptions);\n\n      var cacheableUrl = path.getCacheableUrl(url, options.useQueryParamsInCacheKey);\n      var filePath = path.getImageFilePath(cacheableUrl, options.cacheLocation);\n      return urlCache.remove(cacheableUrl).then(function () {\n        return fs.deleteFile(filePath);\n      });\n    },\n    clearCache: function clearCache() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _.defaults(options, defaultOptions);\n\n      return urlCache.flush().then(function () {\n        return fs.cleanDir(options.cacheLocation);\n      });\n    },\n    getCacheInfo: function getCacheInfo() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _.defaults(options, defaultOptions);\n\n      return fs.getDirInfo(options.cacheLocation);\n    }\n  };\n};","map":{"version":3,"sources":["/home/thecoder/Documentos/votark/votark/node_modules/react-native-cached-image/ImageCacheManager.js"],"names":["_","require","fsUtils","pathUtils","MemoryCache","default","module","exports","defaultOptions","urlCache","fs","path","defaultDefaultOptions","headers","ttl","useQueryParamsInCacheKey","cacheLocation","getCacheDir","allowSelfSignedSSL","defaults","isCacheable","url","isString","startsWith","toLowerCase","cacheUrl","options","getCachedFile","Promise","reject","Error","cacheableUrl","getCacheableUrl","get","then","fileRelativePath","cachedFilePath","exists","catch","getImageRelativeFilePath","filePath","deleteFile","set","downloadAndCacheUrl","downloadFile","seedAndCacheUrl","seedPath","copyFile","deleteUrl","getImageFilePath","remove","clearCache","flush","cleanDir","getCacheInfo","getDirInfo"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nconst fsUtils = require('./utils/fsUtils');\nconst pathUtils = require('./utils/pathUtils');\nconst MemoryCache = require('react-native-clcasher/MemoryCache').default;\n\nmodule.exports = (defaultOptions = {}, urlCache = MemoryCache, fs = fsUtils, path = pathUtils) => {\n\n    const defaultDefaultOptions = {\n        headers: {},\n        ttl: 60 * 60 * 24 * 14, // 2 weeks\n        useQueryParamsInCacheKey: false,\n        cacheLocation: fs.getCacheDir(),\n        allowSelfSignedSSL: false,\n    };\n\n    // apply default options\n    _.defaults(defaultOptions, defaultDefaultOptions);\n\n    function isCacheable(url) {\n        return _.isString(url) && (_.startsWith(url.toLowerCase(), 'http://') || _.startsWith(url.toLowerCase(), 'https://'));\n    }\n\n    function cacheUrl(url, options, getCachedFile) {\n        if (!isCacheable(url)) {\n            return Promise.reject(new Error('Url is not cacheable'));\n        }\n        // allow CachedImage to provide custom options\n        _.defaults(options, defaultOptions);\n        // cacheableUrl contains only the needed query params\n        const cacheableUrl = path.getCacheableUrl(url, options.useQueryParamsInCacheKey);\n        // note: urlCache may remove the entry if it expired so we need to remove the leftover file manually\n        return urlCache.get(cacheableUrl)\n            .then(fileRelativePath => {\n                if (!fileRelativePath) {\n                    // console.log('ImageCacheManager: url cache miss', cacheableUrl);\n                    throw new Error('URL expired or not in cache');\n                }\n                // console.log('ImageCacheManager: url cache hit', cacheableUrl);\n                const cachedFilePath = `${options.cacheLocation}/${fileRelativePath}`;\n\n                return fs.exists(cachedFilePath)\n                    .then((exists) => {\n                        if (exists) {\n                            return cachedFilePath\n                        } else {\n                            throw new Error('file under URL stored in url cache doesn\\'t exsts');\n                        }\n                    });\n            })\n            // url is not found in the cache or is expired\n            .catch(() => {\n                const fileRelativePath = path.getImageRelativeFilePath(cacheableUrl);\n                const filePath = `${options.cacheLocation}/${fileRelativePath}`\n\n                // remove expired file if exists\n                return fs.deleteFile(filePath)\n                    // get the image to cache (download / copy / etc)\n                    .then(() => getCachedFile(filePath))\n                    // add to cache\n                    .then(() => urlCache.set(cacheableUrl, fileRelativePath, options.ttl))\n                    // return filePath\n                    .then(() => filePath);\n            });\n    }\n\n    return {\n\n        /**\n         * download an image and cache the result according to the given options\n         * @param url\n         * @param options\n         * @returns {Promise}\n         */\n        downloadAndCacheUrl(url, options = {}) {\n            return cacheUrl(\n                url,\n                options,\n                filePath => fs.downloadFile(url, filePath, options.headers)\n            );\n        },\n\n        /**\n         * seed the cache for a specific url with a local file\n         * @param url\n         * @param seedPath\n         * @param options\n         * @returns {Promise}\n         */\n        seedAndCacheUrl(url, seedPath, options = {}) {\n            return cacheUrl(\n                url,\n                options,\n                filePath => fs.copyFile(seedPath, filePath)\n            );\n        },\n\n        /**\n         * delete the cache entry and file for a given url\n         * @param url\n         * @param options\n         * @returns {Promise}\n         */\n        deleteUrl(url, options = {}) {\n            if (!isCacheable(url)) {\n                return Promise.reject(new Error('Url is not cacheable'));\n            }\n            _.defaults(options, defaultOptions);\n            const cacheableUrl = path.getCacheableUrl(url, options.useQueryParamsInCacheKey);\n            const filePath = path.getImageFilePath(cacheableUrl, options.cacheLocation);\n            // remove file from cache\n            return urlCache.remove(cacheableUrl)\n                // remove file from disc\n                .then(() => fs.deleteFile(filePath));\n        },\n\n        /**\n         * delete all cached file from the filesystem and cache\n         * @param options\n         * @returns {Promise}\n         */\n        clearCache(options = {}) {\n            _.defaults(options, defaultOptions);\n            return urlCache.flush()\n                .then(() => fs.cleanDir(options.cacheLocation));\n        },\n\n        /**\n         * return info about the cache, list of files and the total size of the cache\n         * @param options\n         * @returns {Promise.<{file: Array, size: Number}>}\n         */\n        getCacheInfo(options = {}) {\n            _.defaults(options, defaultOptions);\n            return fs.getDirInfo(options.cacheLocation);\n        },\n\n    };\n};\n"]},"metadata":{},"sourceType":"script"}