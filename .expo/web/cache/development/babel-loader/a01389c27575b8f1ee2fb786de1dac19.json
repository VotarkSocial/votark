{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar _ = require('lodash');\n\nvar React = require('react');\n\nvar ReactNative = require(\"react-native-web/dist/index\");\n\nvar PropTypes = require('prop-types');\n\nvar ImageCacheManagerOptionsPropTypes = require(\"./ImageCacheManagerOptionsPropTypes\");\n\nvar ImageCacheManager = require(\"./ImageCacheManager\");\n\nvar ImageCachePreloader = require(\"./ImageCachePreloader\");\n\nvar ImageCacheProvider = function (_React$Component) {\n  _inherits(ImageCacheProvider, _React$Component);\n\n  var _super = _createSuper(ImageCacheProvider);\n\n  function ImageCacheProvider(props) {\n    var _this;\n\n    _classCallCheck(this, ImageCacheProvider);\n\n    _this = _super.call(this, props);\n    _this.getImageCacheManagerOptions = _this.getImageCacheManagerOptions.bind(_assertThisInitialized(_this));\n    _this.getImageCacheManager = _this.getImageCacheManager.bind(_assertThisInitialized(_this));\n    _this.preloadImages = _this.preloadImages.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(ImageCacheProvider, [{\n    key: \"getChildContext\",\n    value: function getChildContext() {\n      var self = this;\n      return {\n        getImageCacheManager: function getImageCacheManager() {\n          return self.getImageCacheManager();\n        }\n      };\n    }\n  }, {\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      this.preloadImages(this.props.urlsToPreload);\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      this.imageCacheManager = null;\n\n      if (this.props.urlsToPreload !== nextProps.urlsToPreload) {\n        this.preloadImages(nextProps.urlsToPreload);\n      }\n    }\n  }, {\n    key: \"getImageCacheManagerOptions\",\n    value: function getImageCacheManagerOptions() {\n      return _.pick(this.props, _.keys(ImageCacheManagerOptionsPropTypes));\n    }\n  }, {\n    key: \"getImageCacheManager\",\n    value: function getImageCacheManager() {\n      if (!this.imageCacheManager) {\n        var options = this.getImageCacheManagerOptions();\n        this.imageCacheManager = ImageCacheManager(options);\n      }\n\n      return this.imageCacheManager;\n    }\n  }, {\n    key: \"preloadImages\",\n    value: function preloadImages(urlsToPreload) {\n      var _this2 = this;\n\n      var imageCacheManager = this.getImageCacheManager();\n      ImageCachePreloader.preloadImages(urlsToPreload, imageCacheManager, this.props.numberOfConcurrentPreloads).then(function () {\n        return _this2.props.onPreloadComplete();\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.Children.only(this.props.children);\n    }\n  }]);\n\n  return ImageCacheProvider;\n}(React.Component);\n\nImageCacheProvider.propTypes = _objectSpread(_objectSpread({\n  children: PropTypes.element\n}, ImageCacheManagerOptionsPropTypes), {}, {\n  urlsToPreload: PropTypes.arrayOf(PropTypes.string).isRequired,\n  numberOfConcurrentPreloads: PropTypes.number.isRequired,\n  onPreloadComplete: PropTypes.func.isRequired\n});\nImageCacheProvider.defaultProps = {\n  urlsToPreload: [],\n  numberOfConcurrentPreloads: 0,\n  onPreloadComplete: _.noop\n};\nImageCacheProvider.childContextTypes = {\n  getImageCacheManager: PropTypes.func\n};\nmodule.exports = ImageCacheProvider;","map":{"version":3,"sources":["/home/thecoder/Documentos/votark/votark/node_modules/react-native-cached-image/ImageCacheProvider.js"],"names":["_","require","React","PropTypes","ImageCacheManagerOptionsPropTypes","ImageCacheManager","ImageCachePreloader","ImageCacheProvider","props","getImageCacheManagerOptions","bind","getImageCacheManager","preloadImages","self","urlsToPreload","nextProps","imageCacheManager","pick","keys","options","numberOfConcurrentPreloads","then","onPreloadComplete","Children","only","children","Component","propTypes","element","arrayOf","string","isRequired","number","func","defaultProps","noop","childContextTypes","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,CAAC,GAAGC,OAAO,CAAC,QAAD,CAAjB;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;;;AAGA,IAAME,SAAS,GAAGF,OAAO,CAAC,YAAD,CAAzB;;AAEA,IAAMG,iCAAiC,GAAGH,OAAO,uCAAjD;;AAEA,IAAMI,iBAAiB,GAAGJ,OAAO,uBAAjC;;AACA,IAAMK,mBAAmB,GAAGL,OAAO,yBAAnC;;IAEMM,kB;;;;;AAyBF,8BAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AACf,8BAAMA,KAAN;AAEA,UAAKC,2BAAL,GAAmC,MAAKA,2BAAL,CAAiCC,IAAjC,+BAAnC;AACA,UAAKC,oBAAL,GAA4B,MAAKA,oBAAL,CAA0BD,IAA1B,+BAA5B;AACA,UAAKE,aAAL,GAAqB,MAAKA,aAAL,CAAmBF,IAAnB,+BAArB;AALe;AAOlB;;;;sCAEiB;AACd,UAAMG,IAAI,GAAG,IAAb;AACA,aAAO;AACHF,QAAAA,oBADG,kCACoB;AACnB,iBAAOE,IAAI,CAACF,oBAAL,EAAP;AACH;AAHE,OAAP;AAKH;;;yCAEoB;AACjB,WAAKC,aAAL,CAAmB,KAAKJ,KAAL,CAAWM,aAA9B;AACH;;;8CAEyBC,S,EAAW;AAEjC,WAAKC,iBAAL,GAAyB,IAAzB;;AAEA,UAAI,KAAKR,KAAL,CAAWM,aAAX,KAA6BC,SAAS,CAACD,aAA3C,EAA0D;AACtD,aAAKF,aAAL,CAAmBG,SAAS,CAACD,aAA7B;AACH;AACJ;;;kDAE6B;AAC1B,aAAOd,CAAC,CAACiB,IAAF,CAAO,KAAKT,KAAZ,EAAmBR,CAAC,CAACkB,IAAF,CAAOd,iCAAP,CAAnB,CAAP;AACH;;;2CAEsB;AACnB,UAAI,CAAC,KAAKY,iBAAV,EAA6B;AACzB,YAAMG,OAAO,GAAG,KAAKV,2BAAL,EAAhB;AACA,aAAKO,iBAAL,GAAyBX,iBAAiB,CAACc,OAAD,CAA1C;AACH;;AACD,aAAO,KAAKH,iBAAZ;AACH;;;kCAEaF,a,EAAe;AAAA;;AACzB,UAAME,iBAAiB,GAAG,KAAKL,oBAAL,EAA1B;AACAL,MAAAA,mBAAmB,CAACM,aAApB,CAAkCE,aAAlC,EAAiDE,iBAAjD,EAAoE,KAAKR,KAAL,CAAWY,0BAA/E,EACKC,IADL,CACU;AAAA,eAAM,MAAI,CAACb,KAAL,CAAWc,iBAAX,EAAN;AAAA,OADV;AAEH;;;6BAEQ;AACL,aAAOpB,KAAK,CAACqB,QAAN,CAAeC,IAAf,CAAoB,KAAKhB,KAAL,CAAWiB,QAA/B,CAAP;AACH;;;;EA5E4BvB,KAAK,CAACwB,S;;AAAjCnB,kB,CACKoB,S;AAEHF,EAAAA,QAAQ,EAAEtB,SAAS,CAACyB;GAGjBxB,iC;AAGHU,EAAAA,aAAa,EAAEX,SAAS,CAAC0B,OAAV,CAAkB1B,SAAS,CAAC2B,MAA5B,EAAoCC,U;AACnDX,EAAAA,0BAA0B,EAAEjB,SAAS,CAAC6B,MAAV,CAAiBD,U;AAE7CT,EAAAA,iBAAiB,EAAEnB,SAAS,CAAC8B,IAAV,CAAeF;;AAZpCxB,kB,CAeK2B,Y,GAAe;AAClBpB,EAAAA,aAAa,EAAE,EADG;AAElBM,EAAAA,0BAA0B,EAAE,CAFV;AAGlBE,EAAAA,iBAAiB,EAAEtB,CAAC,CAACmC;AAHH,C;AAfpB5B,kB,CAqBK6B,iB,GAAoB;AACvBzB,EAAAA,oBAAoB,EAAER,SAAS,CAAC8B;AADT,C;AA2D/BI,MAAM,CAACC,OAAP,GAAiB/B,kBAAjB","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst React = require('react');\nconst ReactNative = require('react-native');\n\nconst PropTypes = require('prop-types');\n\nconst ImageCacheManagerOptionsPropTypes = require('./ImageCacheManagerOptionsPropTypes');\n\nconst ImageCacheManager = require('./ImageCacheManager');\nconst ImageCachePreloader = require('./ImageCachePreloader');\n\nclass ImageCacheProvider extends React.Component {\n    static propTypes = {\n        // only a single child so we can render it without adding a View\n        children: PropTypes.element,\n\n        // ImageCacheManager options\n        ...ImageCacheManagerOptionsPropTypes,\n\n        // Preload urls\n        urlsToPreload: PropTypes.arrayOf(PropTypes.string).isRequired,\n        numberOfConcurrentPreloads: PropTypes.number.isRequired,\n\n        onPreloadComplete: PropTypes.func.isRequired,\n    };\n\n    static defaultProps = {\n        urlsToPreload: [],\n        numberOfConcurrentPreloads: 0,\n        onPreloadComplete: _.noop,\n    };\n\n    static childContextTypes = {\n        getImageCacheManager: PropTypes.func,\n    };\n\n    constructor(props) {\n        super(props);\n\n        this.getImageCacheManagerOptions = this.getImageCacheManagerOptions.bind(this);\n        this.getImageCacheManager = this.getImageCacheManager.bind(this);\n        this.preloadImages = this.preloadImages.bind(this);\n\n    }\n\n    getChildContext() {\n        const self = this;\n        return {\n            getImageCacheManager() {\n                return self.getImageCacheManager();\n            }\n        };\n    }\n\n    componentWillMount() {\n        this.preloadImages(this.props.urlsToPreload);\n    }\n\n    componentWillReceiveProps(nextProps) {\n        // reset imageCacheManager in case any option changed\n        this.imageCacheManager = null;\n        // preload new images if needed\n        if (this.props.urlsToPreload !== nextProps.urlsToPreload) {\n            this.preloadImages(nextProps.urlsToPreload);\n        }\n    }\n\n    getImageCacheManagerOptions() {\n        return _.pick(this.props, _.keys(ImageCacheManagerOptionsPropTypes));\n    }\n\n    getImageCacheManager() {\n        if (!this.imageCacheManager) {\n            const options = this.getImageCacheManagerOptions();\n            this.imageCacheManager = ImageCacheManager(options);\n        }\n        return this.imageCacheManager;\n    }\n\n    preloadImages(urlsToPreload) {\n        const imageCacheManager = this.getImageCacheManager();\n        ImageCachePreloader.preloadImages(urlsToPreload, imageCacheManager, this.props.numberOfConcurrentPreloads)\n            .then(() => this.props.onPreloadComplete());\n    }\n\n    render() {\n        return React.Children.only(this.props.children);\n    }\n\n}\n\nmodule.exports = ImageCacheProvider;\n"]},"metadata":{},"sourceType":"script"}