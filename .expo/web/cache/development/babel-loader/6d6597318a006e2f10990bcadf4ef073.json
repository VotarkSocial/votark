{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nvar _marked = _regeneratorRuntime.mark(postFetch),\n    _marked2 = _regeneratorRuntime.mark(watchPostFetch),\n    _marked3 = _regeneratorRuntime.mark(userPostFetch),\n    _marked4 = _regeneratorRuntime.mark(watchUserPostFetch),\n    _marked5 = _regeneratorRuntime.mark(watchTopicSelected);\n\nimport { call, takeEvery, put, select } from 'redux-saga/effects';\nimport * as selectors from \"../reducers\";\nimport * as actions from \"../actions/post\";\nimport * as types from \"../types/posts\";\nimport { API_URL } from \"../../configuration\";\nimport { normalize } from 'normalizr';\nimport * as schemas from \"../schemas/post\";\nimport { TOPIC_SELECTED } from \"../types/topic\";\nvar API_BASE_URL = API_URL + 'api/v1';\n\nfunction postFetch(action) {\n  var isAuth, topicid, token, response, jsonResult, normalized, _yield$response$json, non_field_errors;\n\n  return _regeneratorRuntime.wrap(function postFetch$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return select(selectors.isAuthenticated);\n\n        case 3:\n          isAuth = _context.sent;\n          topicid = action.payload;\n\n          if (!isAuth) {\n            _context.next = 27;\n            break;\n          }\n\n          _context.next = 8;\n          return select(selectors.getAuthToken);\n\n        case 8:\n          token = _context.sent;\n          _context.next = 11;\n          return call(fetch, API_BASE_URL + \"/topic/\" + topicid + \"/order/\", {\n            method: 'GET',\n            headers: {\n              'Content-Type': 'application/json',\n              'Authorization': \"JWT \" + token\n            }\n          });\n\n        case 11:\n          response = _context.sent;\n\n          if (!(response.status === 200)) {\n            _context.next = 21;\n            break;\n          }\n\n          _context.next = 15;\n          return response.json();\n\n        case 15:\n          jsonResult = _context.sent;\n          normalized = normalize(jsonResult, schemas.posts);\n          _context.next = 19;\n          return put(actions.completeFetchPost(normalized.entities.posts, normalized.result));\n\n        case 19:\n          _context.next = 27;\n          break;\n\n        case 21:\n          _context.next = 23;\n          return response.json();\n\n        case 23:\n          _yield$response$json = _context.sent;\n          non_field_errors = _yield$response$json.non_field_errors;\n          _context.next = 27;\n          return put(actions.failFetchPost(non_field_errors[0]));\n\n        case 27:\n          _context.next = 33;\n          break;\n\n        case 29:\n          _context.prev = 29;\n          _context.t0 = _context[\"catch\"](0);\n          _context.next = 33;\n          return put(actions.failFetchPost('CONNECTION FAILED'));\n\n        case 33:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[0, 29]]);\n}\n\nexport function watchPostFetch() {\n  return _regeneratorRuntime.wrap(function watchPostFetch$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return takeEvery(types.POST_FETCH_STARTED, postFetch);\n\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n\nfunction userPostFetch(action) {\n  var isAuth, user, token, response, jsonResult, normalized, _yield$response$json2, non_field_errors;\n\n  return _regeneratorRuntime.wrap(function userPostFetch$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.prev = 0;\n          _context3.next = 3;\n          return select(selectors.isAuthenticated);\n\n        case 3:\n          isAuth = _context3.sent;\n          _context3.next = 6;\n          return select(selectors.getUser);\n\n        case 6:\n          user = _context3.sent;\n\n          if (!(isAuth && user.id)) {\n            _context3.next = 29;\n            break;\n          }\n\n          _context3.next = 10;\n          return select(selectors.getAuthToken);\n\n        case 10:\n          token = _context3.sent;\n          _context3.next = 13;\n          return call(fetch, API_BASE_URL + \"/user/\" + user.id + \"/posts/\", {\n            method: 'GET',\n            headers: {\n              'Content-Type': 'application/json',\n              'Authorization': \"JWT \" + token\n            }\n          });\n\n        case 13:\n          response = _context3.sent;\n\n          if (!(response.status === 200)) {\n            _context3.next = 23;\n            break;\n          }\n\n          _context3.next = 17;\n          return response.json();\n\n        case 17:\n          jsonResult = _context3.sent;\n          normalized = normalize(jsonResult, schemas.posts);\n          _context3.next = 21;\n          return put(actions.completeUserPostFetch(normalized.entities.posts, normalized.result));\n\n        case 21:\n          _context3.next = 29;\n          break;\n\n        case 23:\n          _context3.next = 25;\n          return response.json();\n\n        case 25:\n          _yield$response$json2 = _context3.sent;\n          non_field_errors = _yield$response$json2.non_field_errors;\n          _context3.next = 29;\n          return put(actions.failUserPostFetch(non_field_errors[0]));\n\n        case 29:\n          _context3.next = 35;\n          break;\n\n        case 31:\n          _context3.prev = 31;\n          _context3.t0 = _context3[\"catch\"](0);\n          _context3.next = 35;\n          return put(actions.failUserPostFetch('CONNECTION FAILED'));\n\n        case 35:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3, null, [[0, 31]]);\n}\n\nexport function watchUserPostFetch() {\n  return _regeneratorRuntime.wrap(function watchUserPostFetch$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return takeEvery(types.USER_POSTS_STARTED, userPostFetch);\n\n        case 2:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4);\n}\nexport function watchTopicSelected() {\n  return _regeneratorRuntime.wrap(function watchTopicSelected$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return takeEvery(TOPIC_SELECTED, postFetch);\n\n        case 2:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked5);\n}","map":{"version":3,"sources":["/home/thecoder/Documentos/votark/votark/src/sagas/post.js"],"names":["postFetch","watchPostFetch","userPostFetch","watchUserPostFetch","watchTopicSelected","call","takeEvery","put","select","selectors","actions","types","API_URL","normalize","schemas","TOPIC_SELECTED","API_BASE_URL","action","isAuthenticated","isAuth","topicid","payload","getAuthToken","token","fetch","method","headers","response","status","json","jsonResult","normalized","posts","completeFetchPost","entities","result","non_field_errors","failFetchPost","POST_FETCH_STARTED","getUser","user","id","completeUserPostFetch","failUserPostFetch","USER_POSTS_STARTED"],"mappings":"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","sourcesContent":["import {\n    call,\n    takeEvery,\n    put,\n    // race,\n    // all,\n    select,\n  } from 'redux-saga/effects';\n\nimport * as selectors from '../reducers';\nimport * as actions from '../actions/post';\nimport * as types from '../types/posts';\nimport { API_URL } from '../../configuration';\nimport { normalize } from 'normalizr';\nimport * as schemas from '../schemas/post';\nimport { TOPIC_SELECTED } from '../types/topic';\n  \n  const API_BASE_URL =  API_URL + 'api/v1';\n  \n  function* postFetch(action) {\n    try {\n        const isAuth = yield select(selectors.isAuthenticated);\n        const topicid = action.payload;\n        if (isAuth) {\n          const token = yield select(selectors.getAuthToken);\n          const response = yield call(\n            fetch,\n            `${API_BASE_URL}/topic/${topicid}/order/`,\n            {\n              method: 'GET',\n              headers:{\n                'Content-Type': 'application/json',\n                'Authorization': `JWT ${token}`,\n              },\n            }\n          );\n          if (response.status === 200) {\n            const jsonResult = yield response.json();\n            const normalized = normalize(jsonResult, schemas.posts);\n            yield put(\n            actions.completeFetchPost(\n                normalized.entities.posts,\n                normalized.result\n            ),\n            );\n          } else {\n            const { non_field_errors } = yield response.json();\n            yield put(actions.failFetchPost(non_field_errors[0]));\n          }\n        }\n      } catch (error) {\n        yield put(actions.failFetchPost('CONNECTION FAILED'));\n      }\n  }\n  \n  export function* watchPostFetch() {\n    yield takeEvery(\n      types.POST_FETCH_STARTED,\n      postFetch,\n    );\n  }\n\n  function* userPostFetch(action) {\n    try {\n        const isAuth = yield select(selectors.isAuthenticated);\n        const user = yield select(selectors.getUser);\n        if (isAuth && user.id) {\n          const token = yield select(selectors.getAuthToken);\n          const response = yield call(\n            fetch,\n            `${API_BASE_URL}/user/${user.id}/posts/`,\n            {\n              method: 'GET',\n              headers:{\n                'Content-Type': 'application/json',\n                'Authorization': `JWT ${token}`,\n              },\n            }\n          );\n          if (response.status === 200) {\n            const jsonResult = yield response.json();\n            const normalized = normalize(jsonResult, schemas.posts);\n            yield put(\n            actions.completeUserPostFetch(\n                normalized.entities.posts,\n                normalized.result\n            ),\n            );\n          } else {\n            const { non_field_errors } = yield response.json();\n            yield put(actions.failUserPostFetch(non_field_errors[0]));\n          }\n        }\n      } catch (error) {\n        yield put(actions.failUserPostFetch('CONNECTION FAILED'));\n      }\n  }\n  \n  export function* watchUserPostFetch() {\n    yield takeEvery(\n      types.USER_POSTS_STARTED,\n      userPostFetch,\n    );\n  }\n\n  export function* watchTopicSelected(){\n    yield takeEvery(\n        TOPIC_SELECTED,\n        postFetch,\n    )\n}\n  \n\n  "]},"metadata":{},"sourceType":"module"}