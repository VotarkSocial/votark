{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar URL = require('url-parse');\n\nvar SHA1 = require(\"crypto-js/sha1\");\n\nvar defaultImageTypes = ['png', 'jpeg', 'jpg', 'gif', 'bmp', 'tiff', 'tif'];\n\nfunction serializeObjectKeys(obj) {\n  return _(obj).toPairs().sortBy(function (a) {\n    return a[0];\n  }).map(function (a) {\n    return a[1];\n  }).value();\n}\n\nfunction getQueryForCacheKey(url, useQueryParamsInCacheKey) {\n  if (_.isArray(useQueryParamsInCacheKey)) {\n    return serializeObjectKeys(_.pick(url.query, useQueryParamsInCacheKey));\n  }\n\n  if (useQueryParamsInCacheKey) {\n    return serializeObjectKeys(url.query);\n  }\n\n  return '';\n}\n\nfunction generateCacheKey(url) {\n  var useQueryParamsInCacheKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var parsedUrl = new URL(url, null, true);\n  var pathParts = parsedUrl.pathname.split('/');\n  var fileName = pathParts.pop();\n  var filePath = pathParts.join('/');\n  var parts = fileName.split('.');\n  var fileType = parts.length > 1 ? _.toLower(parts.pop()) : '';\n  var type = defaultImageTypes.includes(fileType) ? fileType : 'jpg';\n  var cacheable = filePath + fileName + type + getQueryForCacheKey(parsedUrl, useQueryParamsInCacheKey);\n  return SHA1(cacheable) + '.' + type;\n}\n\nfunction getHostCachePathComponent(url) {\n  var _URL = new URL(url),\n      host = _URL.host;\n\n  return host.replace(/\\.:/gi, '_').replace(/[^a-z0-9_]/gi, '_').toLowerCase() + '_' + SHA1(host);\n}\n\nmodule.exports = {\n  getImageFilePath: function getImageFilePath(url, cacheLocation) {\n    var hostCachePath = getHostCachePathComponent(url);\n    var cacheKey = generateCacheKey(url);\n    return cacheLocation + \"/\" + hostCachePath + \"/\" + cacheKey;\n  },\n  getImageRelativeFilePath: function getImageRelativeFilePath(url) {\n    var hostCachePath = getHostCachePathComponent(url);\n    var cacheKey = generateCacheKey(url);\n    return hostCachePath + \"/\" + cacheKey;\n  },\n  getCacheableUrl: function getCacheableUrl(url, useQueryParamsInCacheKey) {\n    var parsedUrl = new URL(url, null, true);\n\n    if (_.isArray(useQueryParamsInCacheKey)) {\n      parsedUrl.set('query', _.pick(parsedUrl.query, useQueryParamsInCacheKey));\n    }\n\n    if (!useQueryParamsInCacheKey) {\n      parsedUrl.set('query', {});\n    }\n\n    return parsedUrl.toString();\n  }\n};","map":{"version":3,"sources":["/home/thecoder/Documentos/votark/votark/node_modules/react-native-cached-image/utils/pathUtils.js"],"names":["_","require","URL","SHA1","defaultImageTypes","serializeObjectKeys","obj","toPairs","sortBy","a","map","value","getQueryForCacheKey","url","useQueryParamsInCacheKey","isArray","pick","query","generateCacheKey","parsedUrl","pathParts","pathname","split","fileName","pop","filePath","join","parts","fileType","length","toLower","type","includes","cacheable","getHostCachePathComponent","host","replace","toLowerCase","module","exports","getImageFilePath","cacheLocation","hostCachePath","cacheKey","getImageRelativeFilePath","getCacheableUrl","set","toString"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst URL = require('url-parse');\nconst SHA1 = require(\"crypto-js/sha1\");\n\nconst defaultImageTypes = ['png', 'jpeg', 'jpg', 'gif', 'bmp', 'tiff', 'tif'];\n\nfunction serializeObjectKeys(obj) {\n    return _(obj)\n        .toPairs()\n        .sortBy(a => a[0])\n        .map(a => a[1])\n        .value();\n}\n\nfunction getQueryForCacheKey(url, useQueryParamsInCacheKey) {\n    if (_.isArray(useQueryParamsInCacheKey)) {\n        return serializeObjectKeys(_.pick(url.query, useQueryParamsInCacheKey));\n    }\n    if (useQueryParamsInCacheKey) {\n        return serializeObjectKeys(url.query);\n    }\n    return '';\n}\n\nfunction generateCacheKey(url, useQueryParamsInCacheKey = true) {\n    const parsedUrl = new URL(url, null, true);\n\n    const pathParts = parsedUrl.pathname.split('/');\n\n    // last path part is the file name\n    const fileName = pathParts.pop();\n    const filePath = pathParts.join('/');\n\n    const parts = fileName.split('.');\n    const fileType = parts.length > 1 ? _.toLower(parts.pop()) : '';\n    const type = defaultImageTypes.includes(fileType) ? fileType : 'jpg';\n\n    const cacheable = filePath + fileName + type + getQueryForCacheKey(parsedUrl, useQueryParamsInCacheKey);\n    return SHA1(cacheable) + '.' + type;\n}\n\nfunction getHostCachePathComponent(url) {\n    const {\n        host\n    } = new URL(url);\n\n    return host.replace(/\\.:/gi, '_').replace(/[^a-z0-9_]/gi, '_').toLowerCase()\n      + '_' + SHA1(host);\n}\n\n/**\n * handle the resolution of URLs to local file paths\n */\nmodule.exports = {\n\n    /**\n     * Given a URL and some options returns the file path in the file system corresponding to it's cached image location\n     * @param url\n     * @param cacheLocation\n     * @returns {string}\n     */\n    getImageFilePath(url, cacheLocation) {\n        const hostCachePath = getHostCachePathComponent(url);\n        const cacheKey = generateCacheKey(url);\n\n        return `${cacheLocation}/${hostCachePath}/${cacheKey}`;\n    },\n\n    /**\n     * Given a URL returns the relative file path combined from host and url hash\n     * @param url\n     * @returns {string}\n     */\n\n    getImageRelativeFilePath(url) {\n        const hostCachePath = getHostCachePathComponent(url);\n        const cacheKey = generateCacheKey(url);\n\n        return `${hostCachePath}/${cacheKey}`;\n    },\n\n\n    /**\n     * returns the url after removing all unused query params\n     * @param url\n     * @param useQueryParamsInCacheKey\n     * @returns {string}\n     */\n    getCacheableUrl(url, useQueryParamsInCacheKey) {\n        const parsedUrl = new URL(url, null, true);\n        if (_.isArray(useQueryParamsInCacheKey)) {\n            parsedUrl.set('query', _.pick(parsedUrl.query, useQueryParamsInCacheKey));\n        }\n        if (!useQueryParamsInCacheKey) {\n            parsedUrl.set('query', {});\n        }\n        return parsedUrl.toString();\n    }\n\n};\n"]},"metadata":{},"sourceType":"script"}